blueprint:
  name: Smart Thermostat with Day/Night Sensors
  description: >
    **Version: 1.6.3**

    Intelligent thermostat control using separate day and night temperature sensors with
    dynamic day/night temperature targets and circadian rhythm simulation.
    Automatically switches between sensors based on configurable time schedule
    (default: day sensor 6 AM-10 PM, night sensor 10 PM-6 AM) and adjusts HVAC
    modes and setpoints for optimal comfort throughout the day.
    Uses temperature gradient between indoor and outdoor temperatures to predict natural heating/cooling patterns.
    Ensures fan is never set to 'off' by automatically switching it to 'low'.
    Simple circadian rhythm control: slider sets coolest AM hour and warmest PM hour.

  domain: automation

  input:
    day_target_sensor:
      name: Day Target Temperature Sensor
      description: Temperature sensor to use during daytime hours (e.g., living room)
      selector:
        entity:
          domain: sensor

    night_target_sensor:
      name: Night Target Temperature Sensor
      description: Temperature sensor to use during nighttime hours (e.g., bedroom)
      selector:
        entity:
          domain: sensor

    thermostat:
      name: Thermostat
      description: Climate entity to control
      selector:
        entity:
          domain: climate

    day_temp_input:
      name: Day Target Temperature
      description: Input number for daytime target temperature
      selector:
        entity:
          domain: input_number

    night_temp_input:
      name: Night Target Temperature
      description: Input number for nighttime target temperature
      selector:
        entity:
          domain: input_number

    day_sensor_start_hour:
      name: Day Sensor Start Hour
      description: Hour to switch to day sensor (24-hour format)
      default: 6
      selector:
        number:
          min: 0
          max: 23
          step: 1
          unit_of_measurement: hour

    night_sensor_start_hour:
      name: Night Sensor Start Hour
      description: Hour to switch to night sensor (24-hour format)
      default: 22
      selector:
        number:
          min: 0
          max: 23
          step: 1
          unit_of_measurement: hour

    sensor_timeout:
      name: Sensor Timeout (hours)
      description: Skip automation if sensor hasn't updated within this many hours
      default: 1
      selector:
        number:
          min: 0.5
          max: 6
          step: 0.5
          unit_of_measurement: hours

    min_temp_limit:
      name: Minimum Temperature Limit
      description: Skip if sensor reads below this temperature (°C)
      default: 10
      selector:
        number:
          min: 0
          max: 15
          step: 1
          unit_of_measurement: °C

    max_temp_limit:
      name: Maximum Temperature Limit
      description: Skip if sensor reads above this temperature (°C)
      default: 35
      selector:
        number:
          min: 25
          max: 50
          step: 1
          unit_of_measurement: °C

    use_weather_forecast:
      name: Use Weather Forecast
      description: Enable to use weather forecast data for predictive adjustments.
      selector:
        boolean:
      default: false

    debug_notifications:
      name: Enable Debug Notifications
      description: If enabled, creates a persistent notification with debug data on each run.
      selector:
        boolean:
      default: false

    weather_entity:
      name: Weather Entity
      description: Optional weather entity to use for forecasting natural heating/cooling (leave blank to disable)
      selector:
        entity:
          domain: weather

    forecast_adjustment:
      name: Forecast Adjustment
      description: Temperature adjustment value (°C) to apply when using weather forecast for predictive control
      default: 0.3
      selector:
        number:
          min: 0.1
          max: 1.0
          step: 0.1
          unit_of_measurement: "°C"

    gradient_threshold:
      name: Gradient Threshold
      description: Temperature difference (°C) between indoor and outdoor needed to identify warming/cooling trends
      default: 2.0
      selector:
        number:
          min: 0.5
          max: 5.0
          step: 0.5
          unit_of_measurement: "°C"

    circadian_hour:
      name: Circadian Rhythm Time
      description: Set when temperatures are coolest (AM) and warmest (PM). Value 0=12AM/12PM, 1=1AM/1PM, etc.
      default: 4
      selector:
        number:
          min: 0
          max: 11
          step: 1
          mode: slider

    safety_min_setpoint:
      name: Safety Minimum Setpoint
      description: The minimum allowable temperature setpoint for the thermostat (°C). Prevents setting temperatures that are too low.
      default: 18
      selector:
        number:
          min: 15
          max: 22
          step: 1
          unit_of_measurement: "°C"

    safety_max_setpoint:
      name: Safety Maximum Setpoint
      description: The maximum allowable temperature setpoint for the thermostat (°C). Prevents setting temperatures that are too high.
      default: 28
      selector:
        number:
          min: 23
          max: 32
          step: 1
          unit_of_measurement: "°C"

alias: Smart Thermostat - Auto Mode Switching
description: >-
  Single temperature control with automatic heating/cooling mode switching based
  on bedroom temperature
triggers:
  # This automation runs every 30 minutes to re-evaluate the thermostat settings.
  - trigger: time_pattern
    hours: /1
conditions:
  # --- PRE-EXECUTION CHECKS ---
  # Ensures the automation doesn't run if the thermostat is manually turned off.
  - condition: not
    conditions:
      - condition: state
        entity_id: !input thermostat
        state: "off"
  # Skips execution if the thermostat is in 'away' or 'vacation' mode.
  - condition: not
    conditions:
      - condition: or
        conditions:
          - condition: state
            entity_id: !input thermostat
            attribute: preset_mode
            state: "away"
          - condition: state
            entity_id: !input thermostat
            attribute: preset_mode
            state: "vacation"

  # Verifies that both day and night sensors are providing valid readings.
  - condition: template
    value_template: >
      {{ states(day_target_sensor_entity) not in ['unknown', 'unavailable', 'none']
         and states(night_target_sensor_entity) not in ['unknown', 'unavailable', 'none'] }}
  # Safety check: ensures sensor readings are within a reasonable temperature range.
  - condition: template
    value_template: >
      {{ states(day_target_sensor_entity) | float(0) >= min_temp_limit_value
         and states(night_target_sensor_entity) | float(0) >= min_temp_limit_value }}
  # Another safety check for temperature limits.
  - condition: template
    value_template: >
      {{ states(day_target_sensor_entity) | float(50) <= max_temp_limit_value
         and states(night_target_sensor_entity) | float(50) <= max_temp_limit_value }}
  # Ensures that sensor data is recent, preventing adjustments based on stale information.
  - condition: template
    value_template: >
      {% set timeout_seconds = sensor_timeout_hours * 3600 %}
      {{ (now() - states[day_target_sensor_entity].last_updated).total_seconds() < timeout_seconds
         and (now() - states[night_target_sensor_entity].last_updated).total_seconds() < timeout_seconds }}

actions:
  - choose:
      # This block checks if any sensor is faulty. If so, it sets the thermostat
      # to a safe 'resume' mode and stops processing.
      - conditions:
          - condition: template
            value_template: >
              {% set timeout_seconds = sensor_timeout_hours * 3600 %}
              {% set day_s = day_target_sensor_entity %}
              {% set night_s = night_target_sensor_entity %}

              {% set day_state = states[day_s] %}
              {% set night_state = states[night_s] %}

              {% if day_state is none or day_state.state in ['unknown', 'unavailable', 'none']
                 or night_state is none or night_state.state in ['unknown', 'unavailable', 'none'] %}
                {{ true }}
              {% else %}
                {# Use a default of -99 to ensure it fails the range check if conversion is not possible #}
                {% set day_temp = day_state.state | float(-99) %}
                {% set night_temp = night_state.state | float(-99) %}

                {% set temp_fault = day_temp < min_temp_limit_value or
                                    night_temp < min_temp_limit_value or
                                    day_temp > max_temp_limit_value or
                                    night_temp > max_temp_limit_value %}

                {% set stale_fault = (now() - day_state.last_updated).total_seconds() >= timeout_seconds or
                                     (now() - night_state.last_updated).total_seconds() >= timeout_seconds %}

                {{ temp_fault or stale_fault }}
              {% endif %}
        sequence:
          # If sensors are faulty, set thermostat to 'resume' and send a notification if enabled.
          - service: climate.set_preset_mode
            target:
              entity_id: !input thermostat
            data:
              preset_mode: "resume"
          - choose:
              - conditions: "{{ debug_notifications_enabled }}"
                sequence:
                  - service: persistent_notification.create
                    data:
                      title: "Smart Thermostat ALERT"
                      message: "Faulty sensor data detected. Automation paused and thermostat set to 'resume' mode."

    # If sensors are OK, proceed with the main temperature control logic.
    default:
      # Ensures thermostat fan is not left in 'off' state.
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ state_attr(thermostat_entity, 'fan_mode') in ['off', 'auto'] }}"
            sequence:
              - service: climate.set_fan_mode
                target:
                  entity_id: !input thermostat
                data:
                  fan_mode: "low"
      - choose:
          # This condition checks the 'is_weather_available' variable defined below.
          - conditions: "{{ is_weather_available }}"
            sequence:
              # --- WEATHER ENABLED PATH ---
              # This block executes when weather integration is active.
              # Fetches the hourly weather forecast. The response is stored in 'weather_forecast'.
              - service: weather.get_forecasts
                target:
                  entity_id: "{{ weather_entity }}"
                data:
                  type: hourly
                response_variable: weather_forecast
              - variables:
                  # Extract forecast data from the weather response for use in multiple places
                  forecast_data: >
                    {% if weather_forecast is defined and weather_entity in weather_forecast and 'forecast' in weather_forecast[weather_entity] and weather_forecast[weather_entity].forecast|length >= 1 %}
                      {{ weather_forecast[weather_entity].forecast }}
                    {% else %}
                      []
                    {% endif %}
                  # Determines the upcoming natural temperature trend based on the gradient between
                  # desired indoor temperature and current outdoor temperature
                  natural_trend: >
                    {% if forecast_data|length >= 1 %}
                      {% set current_outdoor = forecast_data[0].temperature|float %}
                      {% set temp_gradient = desired_temp - current_outdoor %}
                      {% if temp_gradient < -gradient_threshold_value %}
                        warming
                      {% elif temp_gradient > gradient_threshold_value %}
                        cooling
                      {% else %}
                        stable
                      {% endif %}
                    {% else %}
                      unknown
                    {% endif %}
                  # Calculates a small temperature adjustment for single-setpoint modes (heat/cool).
                  # It proactively adjusts the setpoint based on the indoor-outdoor temperature gradient
                  natural_heat_cool_adjustment: >
                    {% if natural_trend != 'unknown' and thermostat_mode in ['heat', 'cool'] %}
                      {% if natural_trend == 'warming' and thermostat_mode == 'cool' %} -{{ forecast_adjustment_value }}
                      {% elif natural_trend == 'cooling' and thermostat_mode == 'heat' %} {{ forecast_adjustment_value }}
                      {% else %} 0
                      {% endif %}
                    {% else %} 0
                    {% endif %}
                  # Calculates a temperature adjustment for the heat/cool range mode.
                  # Shifts the entire range up or down based on the natural trend.
                  weather_adjustment_for_range: >
                    {% if natural_trend == 'warming' %} -{{ forecast_adjustment_value }}
                    {% elif natural_trend == 'cooling' %} {{ forecast_adjustment_value }}
                    {% else %} 0
                    {% endif %}
              # These variables calculate the new low and high setpoints for heat/cool mode.
              # They incorporate the standard offset adjustment and the new weather-based adjustment.
              # The result is rounded to the nearest 0.5° to match thermostat hardware constraints.
              - variables:
                  new_target_low: >
                    {% set base_low = current_target_low + offset_adjustment %}
                    {{- ((base_low + weather_adjustment_for_range) * 2) | round / 2 -}}
              - variables:
                  new_target_high: >
                    {% set base_high = current_target_high + offset_adjustment %}
                    {% set preliminary_high = (base_high + weather_adjustment_for_range) %}
                    {% set final_low = new_target_low | float %}
                    {% if preliminary_high < (final_low + 1) %}
                      {{- ((final_low + 1) * 2) | round / 2 -}}
                    {% else %}
                      {{- (preliminary_high * 2) | round / 2 -}}
                    {% endif %}
              # Creates a persistent notification with detailed debug information for troubleshooting.
              - choose:
                  - conditions: "{{ debug_notifications_enabled }}"
                    sequence:
                      - service: persistent_notification.create
                        data:
                          title: "Smart Thermostat DEBUG (Weather ON)"
                          message: >
                            ### Smart Thermostat Status
                            Time: {{ current_hour | round(1) }}h
                            Temperatures: Desired: {{ desired_temp }}°C | Current: {{ current_target_temp }}°C | Diff: {{ temp_difference }}°C
                            Mode: {{ thermostat_mode }} | Needed: {{ needed_mode }}
                            Current Range: {{ current_target_low }}-{{ current_target_high }}°C

                            Weather: {{ natural_trend | title }} | Outdoor: {{ forecast_data[0].temperature|float if forecast_data|length >= 1 else 'N/A' }}°C | Gradient: {{ ((desired_temp - forecast_data[0].temperature|float) | round(1)) if forecast_data|length >= 1 else 'N/A' }}°C

                            {% if offset_adjustment != 0 or weather_adjustment_for_range != 0 %}
                            Action: Adjusting by {{ (offset_adjustment|float + weather_adjustment_for_range|float) | round(1) }}°C → New Range: {{ new_target_low }}-{{ new_target_high }}°C
                            {% if new_target_low == current_target_low and new_target_high == current_target_high %}(No Change){% endif %}
                            {% else %}
                            Action: No temperature adjustment needed
                            {% endif %}
              # Switches the HVAC mode if the calculated 'needed_mode' is different from the current mode.
              # Includes a 10-second delay to allow the thermostat to process the mode change before temperature adjustments.
              - choose:
                  - conditions: "{{ needed_mode != thermostat_mode and needed_mode in ['heat', 'cool', 'heat_cool'] }}"
                    sequence:
                      - service: climate.set_hvac_mode
                        target:
                          entity_id: !input thermostat
                        data:
                          hvac_mode: "{{ needed_mode }}"
                      - delay: "00:00:10"
              # Adjusts the temperature setpoints based on the current HVAC mode.
              - choose:
                  # For 'heat_cool' mode, it sets the new low and high targets.
                  - conditions:
                      - "{{ thermostat_mode == 'heat_cool' }}"
                      - "{{ offset_adjustment != 0 or weather_adjustment_for_range != 0 }}"
                      - "{{ new_target_low != current_target_low or new_target_high != current_target_high }}"
                    sequence:
                      # Safety condition to ensure new setpoints are within a reasonable range.
                      - condition: template
                        value_template: "{{ new_target_low >= safety_min and new_target_high <= safety_max and new_target_low < new_target_high }}"
                      - service: climate.set_temperature
                        target:
                          entity_id: !input thermostat
                        data:
                          target_temp_low: "{{ new_target_low }}"
                          target_temp_high: "{{ new_target_high }}"
                  # For 'heat' or 'cool' modes, it calculates and sets a new single target temperature.
                  - conditions:
                      - "{{ thermostat_mode in ['heat', 'cool'] }}"
                      - "{{ offset_adjustment != 0 or natural_heat_cool_adjustment != 0 }}"
                    sequence:
                      # Calculates the new single setpoint, including offset and weather adjustments,
                      # and rounds it to the nearest 0.5°.
                      - variables:
                          new_target_single: "{{ ((current_target_single + offset_adjustment + natural_heat_cool_adjustment) * 2) | round / 2 }}"
                      # Safety condition to ensure the new setpoint is within a reasonable range.
                      - condition: template
                        value_template: "{{ new_target_single >= safety_min and new_target_single <= safety_max }}"
                      - service: climate.set_temperature
                        target:
                          entity_id: !input thermostat
                        data:
                          temperature: "{{ new_target_single }}"
        default:
          # --- WEATHER DISABLED PATH ---
          # This block executes if the weather integration is disabled or no entity is provided.
          # The logic is a simplified version of the weather-enabled path, without weather adjustments.
          # Calculates the new low and high setpoints, rounded to the nearest 0.5°.
          - variables:
              new_target_low: >
                {% set base_low = current_target_low + offset_adjustment %}
                {{- (base_low * 2) | round / 2 -}}
          - variables:
              new_target_high: >
                {% set base_high = current_target_high + offset_adjustment %}
                {% set final_low = new_target_low | float %}
                {% if base_high < (final_low + 1) %}
                  {{- ((final_low + 1) * 2) | round / 2 -}}
                {% else %}
                  {{- (base_high * 2) | round / 2 -}}
                {% endif %}
          # Creates a persistent notification for debugging, indicating weather is disabled.
          - choose:
              - conditions: "{{ debug_notifications_enabled }}"
                sequence:
                  - service: persistent_notification.create
                    data:
                      title: "Smart Thermostat DEBUG (Weather OFF)"
                      message: >
                        ### Smart Thermostat Status
                        Time: {{ current_hour | round(1) }}h
                        Temperatures: Desired: {{ desired_temp }}°C | Current: {{ current_target_temp }}°C | Diff: {{ temp_difference }}°C
                        Mode: {{ thermostat_mode }} | Needed: {{ needed_mode }}
                        Current Range: {{ current_target_low }}-{{ current_target_high }}°C

                        Weather Integration: Off

                        {% if offset_adjustment != 0 %}
                        Action: Adjusting by {{ offset_adjustment }}°C → New Range: {{ new_target_low }}-{{ new_target_high }}°C
                        {% else %}
                        Action: No temperature adjustment needed
                        {% endif %}
          # Switches HVAC mode if necessary, with a delay.
          - choose:
              - conditions: "{{ needed_mode != thermostat_mode and needed_mode in ['heat', 'cool', 'heat_cool'] }}"
                sequence:
                  - service: climate.set_hvac_mode
                    target:
                      entity_id: !input thermostat
                    data:
                      hvac_mode: "{{ needed_mode }}"
                  - delay: "00:00:10"
          # Adjusts temperature setpoints for the current mode, without weather adjustments.
          - choose:
              - conditions:
                  - "{{ thermostat_mode == 'heat_cool' }}"
                  - "{{ new_target_low != current_target_low or new_target_high != current_target_high }}"
                sequence:
                  - condition: template
                    value_template: "{{ new_target_low >= safety_min and new_target_high <= safety_max and new_target_low < new_target_high }}"
                  - service: climate.set_temperature
                    target:
                      entity_id: !input thermostat
                    data:
                      target_temp_low: "{{ new_target_low }}"
                      target_temp_high: "{{ new_target_high }}"
              - conditions:
                  - "{{ thermostat_mode in ['heat', 'cool'] }}"
                  - "{{ offset_adjustment != 0 }}"
                sequence:
                  - variables:
                      new_target_single: "{{ ((current_target_single + offset_adjustment) * 2) | round / 2 }}"
                  - condition: template
                    value_template: "{{ new_target_single >= safety_min and new_target_single <= safety_max }}"
                  - service: climate.set_temperature
                    target:
                      entity_id: !input thermostat
                    data:
                      temperature: "{{ new_target_single }}"
variables:
  # --- VARIABLE DEFINITIONS ---
  # This section defines all the variables used throughout the automation for clarity and reusability.
  # Aliases for blueprint inputs to make templates cleaner.
  day_target_sensor_entity: !input day_target_sensor
  night_target_sensor_entity: !input night_target_sensor
  thermostat_entity: !input thermostat
  day_temp_input_entity: !input day_temp_input
  night_temp_input_entity: !input night_temp_input
  day_start_hour: !input day_sensor_start_hour
  night_start_hour: !input night_sensor_start_hour
  sensor_timeout_hours: !input sensor_timeout
  min_temp_limit_value: !input min_temp_limit
  max_temp_limit_value: !input max_temp_limit
  weather_entity: !input weather_entity
  use_weather_forecast_input: !input use_weather_forecast
  debug_notifications_enabled: !input debug_notifications
  forecast_adjustment_value: !input forecast_adjustment
  gradient_threshold_value: !input gradient_threshold
  circadian_hour_value: !input circadian_hour

  # Safety setpoint limits from blueprint inputs.
  safety_min: !input safety_min_setpoint
  safety_max: !input safety_max_setpoint

  # Determines if the weather feature should be used.
  # Checks if the toggle is enabled, an entity is provided, and the entity is not in an error state.
  is_weather_available: "{{ use_weather_forecast_input and weather_entity != none and weather_entity|length > 0 and states(weather_entity) not in ['unavailable', 'unknown', 'none'] }}"

  # Dynamically selects the active temperature sensor (day or night) based on the current time
  # and the configured start hours for day and night periods.
  current_target_sensor_entity: >
    {% set hour = now().hour %}
    {% set day_start = day_start_hour | int %}
    {% set night_start = night_start_hour | int %}
    {% if day_start < night_start %}
      {# Normal case: day_start=6, night_start=22 -> day sensor 6-21, night sensor 22-5 #}
      {% if hour >= day_start and hour < night_start %}
        {{ day_target_sensor_entity }}
      {% else %}
        {{ night_target_sensor_entity }}
      {% endif %}
    {% else %}
      {# Edge case: night_start < day_start (e.g., day_start=22, night_start=6) #}
      {% if hour >= night_start and hour < day_start %}
        {{ night_target_sensor_entity }}
      {% else %}
        {{ day_target_sensor_entity }}
      {% endif %}
    {% endif %}

  # Fetches the target temperatures from the input_number helpers.
  day_temp: "{{ states(day_temp_input_entity) | float(24) }}"
  night_temp: "{{ states(night_temp_input_entity) | float(20) }}"
  # Gets the current hour as a float (e.g., 18.5 for 6:30 PM) for use in calculations.
  current_hour: "{{ now().hour + (now().minute / 60.0) }}"

  # Calculates the "desired" temperature at any given moment using a cosine curve.
  # This simulates a natural circadian rhythm with the coolest temperature at the selected AM hour
  # and warmest at the same PM hour (12 hours later).
  desired_temp: >
    {% set day_temp = states(day_temp_input_entity) | float(24) %}
    {% set night_temp = states(night_temp_input_entity) | float(20) %}
    {% set hour = now().hour + (now().minute / 60.0) %}
    {% set temp_range = day_temp - night_temp %}
    {% set coolest_hour = circadian_hour_value | int %}
    {% if coolest_hour == 0 %}
      {% set coolest_hour = 0 %}
    {% endif %}

    {# Create smooth curve: coolest at the selected AM hour, warmest 12 hours later #}
    {% set phase = (hour - coolest_hour) * 15 %}  {# Convert to degrees (24h = 360°) #}
    {% set curve = (1 - cos(phase | float * 3.14159 / 180)) / 2 %} {# Inverted curve #}
    {% set dynamic_temp = night_temp + (temp_range * curve) %}

    {{ dynamic_temp | round(1) }}

  # Core temperature and thermostat state variables.
  current_target_temp: "{{ states(current_target_sensor_entity) | float(22) }}"
  thermostat_mode: "{{ states(thermostat_entity) }}"
  hvac_action: "{{ state_attr(thermostat_entity, 'hvac_action') }}"
  # The difference between the room's current temperature and the calculated desired temperature.
  temp_difference: "{{ (current_target_temp - desired_temp) | round(1) }}"
  # Current temperature setpoints from the thermostat.
  current_target_low: "{{ state_attr(thermostat_entity, 'target_temp_low') | float(22) }}"
  current_target_high: "{{ state_attr(thermostat_entity, 'target_temp_high') | float(23) }}"
  current_target_single: "{{ state_attr(thermostat_entity, 'temperature') | float(22) }}"
  # Determines the required HVAC mode (heat, cool, or heat_cool) based on the temperature difference.
  # It will suggest switching modes if the temperature is significantly off target (e.g., > 0.7°C)
  # to prevent rapid cycling between heating and cooling.
  needed_mode: >
    {% set diff = temp_difference %}
    {% if thermostat_mode == 'heat_cool' %}
      heat_cool
    {% elif thermostat_mode == 'heat' and diff > 0.7 %}
      cool
    {% elif thermostat_mode == 'cool' and diff < -0.7 %}
      heat
    {% else %}
      {{ thermostat_mode }}
    {% endif %}
  # Calculates a standard temperature adjustment offset. If the temperature is off by
  # more than 0.5° from the desired temp, it creates a 0.5° adjustment to correct it.
  offset_adjustment: >
    {% set diff = temp_difference %}
    {% if diff <= -0.5 %}
      0.5
    {% elif diff >= 0.5 %}
      -0.5
    {% else %}
      0
    {% endif %}
