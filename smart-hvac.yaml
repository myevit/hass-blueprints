blueprint:
  name: Smart Thermostat with Day/Night Sensors
  description: |
    **Version: 1.12.0**

    MAIN GOAL
    â€¢ Use an external (often more accurate or conveniently placed) temperature sensor to steer a thermostat that cannot natively follow that sensor.  The automation transparently nudges set-points so the HVAC keeps the **room**â€”not just the thermostatâ€”within your comfort band.
    â€¢ Ordering rule enforced at every cycle:
      safety_min  <  night_temp  â‰¤  (desired Â± 0.5 Â°C)  â‰¤  day_temp  <  safety_max

    Smart single-zone thermostat brain for Home Assistant.

    WHAT IT DOES
    â€¢ Chooses a *Day* or *Night* room sensor automatically by the clock.
    â€¢ Glides between your Day and Night target temps using a smooth circadian curve.
    â€¢ Every 60 min decides whether to Heat, Cool or Heat-Cool and gently nudges the set-points toward the target.
    â€¢ Optimized for Android tablet performance with modular, testable template components.
    â€¢ Can factor in outdoor weather/temperature and solar impact to anticipate natural trends and save energy.
    â€¢ Keeps the fan from ever being 'off' (great for ERV/HRV systems).
    â€¢ Optional toggle lets the blueprint switch between *heat* and *cool* when the thermostat is operating in a single-mode.  When the thermostat itself is on *auto/heat_cool* the automation never changes mode.

    HOW TO USE
    1. Pick your Day & Night sensors.
    2. Choose whether each target temp comes from an *input_number* helper or a fixed value.
    3. Set the hours when each sensor becomes active (e.g. Day 06:00, Night 22:00).
    4. (Optional) Toggle weather and outdoor-temp sensor support and tune the adjustment factors.
    5. Turn on *Debug Notifications* to see a step-by-step breakdown in Home Assistant.

    SAFETY FIRST
    â€¢ Automation aborts if any sensor/thermostat data is stale, unknown or outside your min/max limits and explains why.
    â€¢ All set-points are clamped between the safety min/max values you define.

    Zero YAML edits requiredâ€”everything is configurable via the blueprint UI.

  domain: automation

  input:
    day_target_sensor:
      name: Day Target Temperature Sensor
      description: Temperature sensor to use during daytime hours (e.g., living room)
      selector:
        entity:
          filter:
            domain: sensor

    night_target_sensor:
      name: Night Target Temperature Sensor
      description: Temperature sensor to use during nighttime hours (e.g., bedroom)
      selector:
        entity:
          filter:
            domain: sensor

    thermostat:
      name: Thermostat
      description: Climate entity to control
      selector:
        entity:
          filter:
            domain: climate

    day_temp_input:
      name: Day Target Temperature
      description: Input number for daytime target temperature
      selector:
        entity:
          filter:
            domain: input_number

    night_temp_input:
      name: Night Target Temperature
      description: Input number for nighttime target temperature
      selector:
        entity:
          filter:
            domain: input_number

    # --- DAY & NIGHT TARGET TEMPERATURE MODE TOGGLES ---
    use_day_temp_input:
      name: Use Day Temperature Helper
      description: Enable to read the daytime target from an input_number helper. Disable to use the fixed value below.
      selector:
        boolean:
      default: true

    day_temp_static:
      name: Day Target Temperature (Fixed)
      description: Fixed daytime target temperature when helper is disabled
      default: 22
      selector:
        number:
          min: 10
          max: 35
          step: 0.5
          unit_of_measurement: "Â°C"

    use_night_temp_input:
      name: Use Night Temperature Helper
      description: Enable to read the nighttime target from an input_number helper. Disable to use the fixed value below.
      selector:
        boolean:
      default: true

    night_temp_static:
      name: Night Target Temperature (Fixed)
      description: Fixed nighttime target temperature when helper is disabled
      default: 20
      selector:
        number:
          min: 10
          max: 35
          step: 0.5
          unit_of_measurement: "Â°C"

    day_sensor_start_hour:
      name: Day Sensor Start Hour
      description: Hour to switch to day sensor (24-hour format)
      default: 6
      selector:
        number:
          min: 0
          max: 23
          step: 1
          unit_of_measurement: hour

    night_sensor_start_hour:
      name: Night Sensor Start Hour
      description: Hour to switch to night sensor (24-hour format)
      default: 22
      selector:
        number:
          min: 0
          max: 23
          step: 1
          unit_of_measurement: hour

    sensor_timeout:
      name: Sensor Timeout (hours)
      description: Skip automation if sensor hasn't updated within this many hours
      default: 2
      selector:
        number:
          min: 0.5
          max: 6
          step: 0.5
          unit_of_measurement: hours

    min_temp_limit:
      name: Minimum Temperature Limit
      description: Skip if sensor reads below this temperature (Â°C)
      default: 10
      selector:
        number:
          min: 0
          max: 15
          step: 1
          unit_of_measurement: Â°C

    max_temp_limit:
      name: Maximum Temperature Limit
      description: Skip if sensor reads above this temperature (Â°C)
      default: 35
      selector:
        number:
          min: 25
          max: 50
          step: 1
          unit_of_measurement: Â°C

    use_weather_forecast:
      name: Use Weather Forecast
      description: Enable to use weather forecast data for predictive adjustments.
      selector:
        boolean:
      default: false

    debug_notifications:
      name: Enable Debug Notifications
      description: If enabled, creates a persistent notification with debug data on each run.
      selector:
        boolean:
      default: false

    weather_entity:
      name: Weather Entity
      description: Optional weather entity to use for forecasting natural heating/cooling (leave blank to disable)
      selector:
        entity:
          filter:
            domain: weather

    outdoor_temp_sensor:
      name: Outdoor Temperature Sensor
      description: Optional real-time outdoor temperature sensor (more accurate than weather forecast)
      selector:
        entity:
          filter:
            domain: sensor
      default: ""



    use_outdoor_temp_sensor:
      name: Use Outdoor Temperature Sensor
      description: Enable to include the outdoor temperature sensor in calculations.
      selector:
        boolean:
      default: false



    solar_adjustment:
      name: Solar Impact Factor
      description: Adjustment factor for direct sunlight impact (higher = stronger impact)
      default: 0.5
      selector:
        number:
          min: 0.1
          max: 1.0
          step: 0.1
          unit_of_measurement: factor

    forecast_adjustment:
      name: Forecast Adjustment
      description: Temperature adjustment value (Â°C) to apply when using weather forecast for predictive control
      default: 0.3
      selector:
        number:
          min: 0.1
          max: 1.0
          step: 0.1
          unit_of_measurement: "Â°C"

    gradient_threshold:
      name: Gradient Threshold
      description: Temperature difference (Â°C) between indoor and outdoor needed to identify warming/cooling trends
      default: 2.0
      selector:
        number:
          min: 0.5
          max: 5.0
          step: 0.5
          unit_of_measurement: "Â°C"

    circadian_hour:
      name: Circadian Rhythm Time
      description: Set when temperatures are coolest (AM) and warmest (PM). Value 0=12AM/12PM, 1=1AM/1PM, etc.
      default: 2
      selector:
        number:
          min: 0
          max: 11
          step: 1
          mode: slider

    safety_min_setpoint:
      name: Safety Minimum Setpoint
      description: The minimum allowable temperature setpoint for the thermostat (Â°C). Prevents setting temperatures that are too low.
      default: 18
      selector:
        number:
          min: 15
          max: 22
          step: 1
          unit_of_measurement: "Â°C"

    safety_max_setpoint:
      name: Safety Maximum Setpoint
      description: The maximum allowable temperature setpoint for the thermostat (Â°C). Prevents setting temperatures that are too high.
      default: 28
      selector:
        number:
          min: 23
          max: 32
          step: 1
          unit_of_measurement: "Â°C"

    # --- FAN MODE ENFORCEMENT ---
    enforce_fan_mode:
      name: Enforce Fan Mode
      description: Ensure the thermostat fan is set to a specific mode after every run.
      selector:
        boolean:
      default: true

    fan_mode_setting:
      name: Fan Mode to Enforce
      description: Fan mode that will be applied when enforcement is enabled.
      selector:
        select:
          options:
            - "low"
            - "medium"
            - "high"
            - "on"
            - "auto"
      default: "low"

    # --- MODE SWITCHING CONTROL ---
    allow_mode_switch:
      name: Allow Automatic Mode Switching
      description: Enable to let the automation flip between *heat* and *cool* modes when the thermostat is currently in a single-setpoint mode. No changes are made when the thermostat is set to *heat_cool*.
      selector:
        boolean:
      default: false

alias: Smart Thermostat - Auto Mode Switching
description: >-
  Single temperature control with automatic heating/cooling mode switching based
  on bedroom temperature
triggers:
  # This automation runs every 30 minutes to re-evaluate the thermostat settings.
  - trigger: time_pattern
    hours: /1
conditions:
  # --- PRE-EXECUTION CHECKS ---
  # Ensures the automation doesn't run if the thermostat is manually turned off.
  - condition: not
    conditions:
      - condition: state
        entity_id: !input thermostat
        state: "off"
  # Skips execution if the thermostat is in 'away' or 'vacation' mode.
  - condition: not
    conditions:
      - condition: or
        conditions:
          - condition: state
            entity_id: !input thermostat
            attribute: preset_mode
            state: "away"
          - condition: state
            entity_id: !input thermostat
            attribute: preset_mode
            state: "vacation"
  # Only runs automation if thermostat is in a temperature control mode (heat, cool, or heat_cool)
  - condition: template
    value_template: "{{ states(thermostat_entity) in ['heat', 'cool', 'heat_cool'] }}"

actions:
  # Early safety check â€“ aborts execution (with optional debug) if sensor validation fails
  - choose:
      - conditions: "{{ not sensors_valid }}"
        sequence:
          - choose:
              - conditions: "{{ debug_notifications_enabled }}"
                sequence:
                  - service: persistent_notification.create
                    data:
                      title: "ðŸ›¡ï¸ Smart Thermostat Safety Check Failed"
                      message: |-
                        **Automation skipped due to sensor validation failure.**

                        **Current Readings:**
                        â€¢ Day sensor: {{ states(day_target_sensor_entity) }} Â°C ({{ day_target_sensor_entity }})
                        â€¢ Night sensor: {{ states(night_target_sensor_entity) }} Â°C ({{ night_target_sensor_entity }})
                        â€¢ Thermostat: {{ state_attr(thermostat_entity, 'current_temperature') | default('unknown') }} Â°C ({{ thermostat_entity }})

                        **Data Freshness:**
                        â€¢ Day sensor: {{ ((now() - states[day_target_sensor_entity].last_updated).total_seconds() / 60) | round(1) }} minutes ago
                        â€¢ Night sensor: {{ ((now() - states[night_target_sensor_entity].last_updated).total_seconds() / 60) | round(1) }} minutes ago
                        â€¢ Thermostat: {{ ((now() - states[thermostat_entity].last_updated).total_seconds() / 60) | round(1) }} minutes ago
                        â€¢ **Timeout limit:** {{ sensor_timeout_hours }} hours ({{ (sensor_timeout_hours * 60) | round(0) }} minutes)

                        **Temperature Limits:** {{ min_temp_limit_value }} â€“ {{ max_temp_limit_value }} Â°C

                        {% set day_age_minutes = ((now() - states[day_target_sensor_entity].last_updated).total_seconds() / 60) %}
                        {% set night_age_minutes = ((now() - states[night_target_sensor_entity].last_updated).total_seconds() / 60) %}
                        {% set thermostat_age_minutes = ((now() - states[thermostat_entity].last_updated).total_seconds() / 60) %}
                        {% set timeout_minutes = sensor_timeout_hours * 60 %}
                        {% if day_age_minutes > timeout_minutes or night_age_minutes > timeout_minutes or thermostat_age_minutes > timeout_minutes %}
                        **Issue:** Sensor data is stale (older than {{ (sensor_timeout_hours * 60) | round(0) }} minutes)
                        **Solution:** Check sensor connectivity or increase timeout in blueprint settings
                        {% else %}
                        **Issue:** Temperature readings outside valid range
                        **Solution:** Check sensor calibration or adjust temperature limits
                        {% endif %}

                        **Note:** If you are using an *average* or *statistics* sensor, its `last_updated` timestamp only updates when the calculated value changes. When the temperature is stable, this can make a healthy sensor look stale. If this is the case, consider increasing the *Sensor Timeout* in the blueprint settings or switch to a raw sensor for freshness checks.
          - stop: "Safety check failed â€“ automation halted"

  # Weather-enabled path
  - choose:
      - conditions: "{{ is_weather_available }}"
        sequence:
          # --- WEATHER ENABLED PATH ---
          # This block executes when weather integration is active.
          # Fetches the hourly weather forecast. The response is stored in 'weather_forecast'.
          - service: weather.get_forecasts
            target:
              entity_id: "{{ weather_entity }}"
            data:
              type: hourly
            response_variable: weather_forecast
          - variables:
              # Extract forecast data from the weather response for use in multiple places
              forecast_data: >
                {% if weather_forecast is defined and weather_entity in weather_forecast and 'forecast' in weather_forecast[weather_entity] and weather_forecast[weather_entity].forecast|length >= 1 %}
                  {{ weather_forecast[weather_entity].forecast }}
                {% else %}
                  []
                {% endif %}

              # Determine the current outdoor temperature, preferring the real sensor if available
              current_outdoor_temp: >
                {% if outdoor_temp_entity != "" and states(outdoor_temp_entity) not in ['unknown', 'unavailable', 'none'] %}
                  {{ states(outdoor_temp_entity) | float }}
                {% elif forecast_data|length >= 1 %}
                  {{ forecast_data[0].temperature|float }}
                {% else %}
                  {{ states(weather_entity).attributes.temperature|default(20)|float }}
                {% endif %}

              # Get the current weather condition from the forecast
              current_condition: >
                {% if forecast_data|length >= 1 %}
                  {{ forecast_data[0].condition }}
                {% else %}
                  {{ states(weather_entity).attributes.condition|default('unknown') }}
                {% endif %}

              # Use pre-calculated solar impact for better performance
              solar_impact: "{{ solar_impact_factor }}"

              # Determine the thermal contribution of the building envelope
              # This considers wall thermal mass effects based on outdoor temperature trends
              building_thermal_contribution: >
                {% if forecast_data|length >= 3 %}
                  {% set now_temp = current_outdoor_temp %}
                  {% set prev_temp = forecast_data[1].temperature|float %}
                  {% set trend_strength = (now_temp - prev_temp)|abs %}

                  {% if trend_strength > 1 %}
                    {% if now_temp > prev_temp %}
                      warming
                    {% else %}
                      cooling
                    {% endif %}
                  {% else %}
                    stable
                  {% endif %}
                {% else %}
                  stable
                {% endif %}

              # Use pre-calculated natural trend for performance optimization
              natural_trend: "{{ natural_thermal_trend }}"

              # Weather adjustment calculation based on solar and trend factors
              weather_adjustment_factor: >
                {% set base_factor = forecast_adjustment_value %}
                {% set solar_factor = solar_impact|float %}

                {% if natural_trend == 'warming' %}
                  {# More conservative adjustment for warming trends to prevent over-cooling #}
                  {% set temp_diff = current_outdoor_temp|float - desired_temp|float %}
                  {% if temp_diff > 0 and temp_difference > 0 %}
                    {# Only make significant cooling adjustments if both outdoor temp is higher than desired
                       AND current indoor temp is above desired temp #}
                    {{ (base_factor + solar_factor) * -0.7 }}
                  {% elif temp_difference < 0 %}
                    {# If indoor temp is already below desired, don't make negative adjustments #}
                    0
                  {% else %}
                    {# Minimal adjustment in other warming scenarios #}
                    {{ (base_factor + solar_factor) * -0.3 }}
                  {% endif %}
                {% elif natural_trend == 'cooling' %}
                  {% if temp_difference < 0 %}
                    {# If room is already cooler than desired in cooling trend, apply positive adjustment #}
                    {{ base_factor | abs }}
                  {% else %}
                    {{ base_factor }}
                  {% endif %}
                {% else %}
                  0
                {% endif %}

              # Calculates a small temperature adjustment for single-setpoint modes (heat/cool).
              # It proactively adjusts the setpoint based on the indoor-outdoor temperature gradient
              natural_heat_cool_adjustment: >
                {% if natural_trend != 'unknown' and thermostat_mode in ['heat', 'cool'] %}
                  {% if natural_trend == 'warming' and thermostat_mode == 'cool' %} {{ weather_adjustment_factor }}
                  {% elif natural_trend == 'cooling' and thermostat_mode == 'heat' %} {{ weather_adjustment_factor|abs }}
                  {% else %} 0
                  {% endif %}
                {% else %} 0
                {% endif %}

              # Calculates a temperature adjustment for the heat/cool range mode.
              # Shifts the entire range up or down based on the natural trend.
              weather_adjustment_for_range: "{{ weather_adjustment_factor }}"

          # Calculate new target setpoints with directional adjustments
          - variables:
              # Calculate the new heating setpoint
              calculated_low: >-
                {% if thermostat_mode == 'heat_cool' %}
                  {# If the room temp is already inside the desired band we leave the band unchanged #}
                  {% if offset_adjustment == 0 %}
                    {{ current_target_low }}
                  {% else %}
                    {# Build heat_cool low set-point obeying ordering and Â±0.5 Â°C step cap #}
                    {% set desired_band_low = ((desired_temp - 0.5) * 2) | round / 2 %}
                    {% set low_candidate = [ desired_band_low, night_temp, safety_min ] | max %}
                    {% set high_limit = [ day_temp, safety_max ] | min %}
                    {% set low_final = [ low_candidate, high_limit - 1 ] | min %}

                    {% set delta = low_final - current_target_low %}
                    {% if delta > 0.5 %}
                      {{ (current_target_low + 0.5) | round(1) }}
                    {% elif delta < -0.5 %}
                      {{ (current_target_low - 0.5) | round(1) }}
                    {% else %}
                      {{ low_final }}
                    {% endif %}
                  {% endif %}
                {% else %}
                  {% if offset_adjustment > 0 %}
                    {{ ((current_target_low + offset_adjustment|abs) * 2) | round / 2 }}
                  {% elif temp_difference > 0.5 and natural_trend == 'warming' %}
                    {% if weather_adjustment_for_range|float < 0 %}
                      {{ ((current_target_low + weather_adjustment_for_range) * 2) | round / 2 }}
                    {% else %}
                      {{ current_target_low }}
                    {% endif %}
                  {% else %}
                    {{ current_target_low }}
                  {% endif %}
                {% endif %}

          - variables:
              # Calculate the new cooling setpoint
              calculated_high: >-
                {% if thermostat_mode == 'heat_cool' %}
                  {# If the room temp is already inside the desired band we leave the band unchanged #}
                  {% if offset_adjustment == 0 %}
                    {{ current_target_high }}
                  {% else %}
                    {% set raw_high = calculated_low + 1 %}
                    {% set high_cap = [ day_temp, safety_max ] | min %}
                    {% set new_high = [ raw_high, high_cap ] | min %}
                    {% set delta_high = new_high - current_target_high %}
                    {% if delta_high > 0.5 %}
                      {{ (current_target_high + 0.5) | round(1) }}
                    {% elif delta_high < -0.5 %}
                      {{ (current_target_high - 0.5) | round(1) }}
                    {% else %}
                      {{ new_high }}
                    {% endif %}
                  {% endif %}
                {% else %}
                  {% if offset_adjustment < 0 %}
                    {{ ((current_target_high + offset_adjustment) * 2) | round / 2 }}
                  {% elif temp_difference < -0.5 and natural_trend == 'cooling' %}
                    {% if weather_adjustment_for_range|float > 0 %}
                      {{ ((current_target_high + weather_adjustment_for_range) * 2) | round / 2 }}
                    {% else %}
                      {{ current_target_high }}
                    {% endif %}
                  {% else %}
                    {{ current_target_high }}
                  {% endif %}
                {% endif %}

          - variables:
              # Ensure minimum 1Â°C difference between setpoints by adjusting whichever setpoint changed less
              final_calculation: >-
                {% set low = calculated_low|float %}
                {% set high = calculated_high|float %}
                {% set low_change = (low - current_target_low|float)|abs %}
                {% set high_change = (high - current_target_high|float)|abs %}

                {% if (high - low) < 1 %}
                  {% if low_change <= high_change %}
                    {# The low setpoint changed less, so adjust it downward #}
                    low:{{ high - 1 }};high:{{ high }}
                  {% else %}
                    {# The high setpoint changed less, so adjust it upward #}
                    {% set new_high = ((low + 1) * 2) | round / 2 %}
                    low:{{ low }};high:{{ new_high }}
                  {% endif %}
                {% else %}
                  low:{{ low }};high:{{ high }}
                {% endif %}

          - variables:
              # Extract adjusted values using string parsing
              adjusted_low: >-
                {% set parts = final_calculation.split(';') %}
                {% set low_part = parts[0].split(':') %}
                {{ low_part[1]|float }}
              adjusted_high: >-
                {% set parts = final_calculation.split(';') %}
                {% set high_part = parts[1].split(':') %}
                {{ high_part[1]|float }}
              new_target_low: "{{ adjusted_low }}"
              new_target_high: "{{ adjusted_high }}"

          # Switches the HVAC mode if the calculated 'needed_mode' is different from the current mode.
          - choose:
              - conditions: "{{ allow_mode_switch_input and thermostat_mode != 'heat_cool' and needed_mode != thermostat_mode and needed_mode in ['heat','cool'] }}"
                sequence:
                  - service: climate.set_hvac_mode
                    target:
                      entity_id: !input thermostat
                    data:
                      hvac_mode: "{{ needed_mode }}"
          # Adjusts the temperature setpoints based on the current HVAC mode.
          - choose:
              # For 'heat_cool' mode, it sets the new low and high targets.
              - conditions:
                  - "{{ thermostat_mode == 'heat_cool' }}"
                  - "{{ offset_adjustment != 0 or weather_adjustment_for_range != 0 }}"
                  - "{{ new_target_low != current_target_low or new_target_high != current_target_high }}"
                sequence:
                  # Safety condition to ensure new setpoints are within a reasonable range.
                  - condition: template
                    value_template: "{{ new_target_low >= safety_min and new_target_high <= safety_max and new_target_low < new_target_high }}"
                  - service: climate.set_temperature
                    target:
                      entity_id: !input thermostat
                    data:
                      target_temp_low: "{{ new_target_low }}"
                      target_temp_high: "{{ new_target_high }}"
              # For 'heat' or 'cool' modes, it calculates and sets a new single target temperature.
              - conditions:
                  - "{{ thermostat_mode in ['heat', 'cool'] }}"
                  - "{{ offset_adjustment != 0 or natural_heat_cool_adjustment != 0 }}"
                sequence:
                  # Calculates the new single setpoint, including offset and weather adjustments,
                  # and rounds it to the nearest 0.5Â°.
                  - variables:
                      new_target_single: "{{ ((current_target_single + offset_adjustment + natural_heat_cool_adjustment) * 2) | round / 2 }}"
                  # Safety condition to ensure the new setpoint is within a reasonable range.
                  - condition: template
                    value_template: "{{ new_target_single >= safety_min and new_target_single <= safety_max }}"
                  - service: climate.set_temperature
                    target:
                      entity_id: !input thermostat
                    data:
                      temperature: "{{ new_target_single }}"

    default:
      # --- WEATHER DISABLED PATH ---
      # This block executes if the weather integration is disabled or no entity is provided.
      # The logic is a simplified version of the weather-enabled path, without weather adjustments.
      # Calculate new target setpoints with directional adjustments
      - variables:
          # Calculate the new heating setpoint
          calculated_low: >-
            {% if thermostat_mode == 'heat_cool' %}
              {% set desired_band_low = ((desired_temp - 0.5) * 2) | round / 2 %}
              {% set low_candidate = [ desired_band_low, night_temp, safety_min ] | max %}
              {% set high_limit = [ day_temp, safety_max ] | min %}
              {% set low_final = [ low_candidate, high_limit - 1 ] | min %}

              {% set delta = low_final - current_target_low %}
              {% if delta > 0.5 %}
                {{ (current_target_low + 0.5) | round(1) }}
              {% elif delta < -0.5 %}
                {{ (current_target_low - 0.5) | round(1) }}
              {% else %}
                {{ low_final }}
              {% endif %}
            {% elif offset_adjustment > 0 %}
              {{ ((current_target_low + offset_adjustment|abs) * 2) | round / 2 }}
            {% else %}
              {{ current_target_low }}
            {% endif %}

      - variables:
          # Calculate the new cooling setpoint
          calculated_high: >-
            {% if thermostat_mode == 'heat_cool' %}
              {% set raw_high = calculated_low + 1 %}
              {% set high_cap = [ day_temp, safety_max ] | min %}
              {% set new_high = [ raw_high, high_cap ] | min %}
              {% set delta_high = new_high - current_target_high %}
              {% if delta_high > 0.5 %}
                {{ (current_target_high + 0.5) | round(1) }}
              {% elif delta_high < -0.5 %}
                {{ (current_target_high - 0.5) | round(1) }}
              {% else %}
                {{ new_high }}
              {% endif %}
            {% elif offset_adjustment < 0 %}
              {{ ((current_target_high + offset_adjustment) * 2) | round / 2 }}
            {% else %}
              {{ current_target_high }}
            {% endif %}

      - variables:
          # Ensure minimum 1Â°C difference between setpoints by adjusting whichever setpoint changed less
          final_calculation: >-
            {% set low = calculated_low|float %}
            {% set high = calculated_high|float %}
            {% set low_change = (low - current_target_low|float)|abs %}
            {% set high_change = (high - current_target_high|float)|abs %}

            {% if (high - low) < 1 %}
              {% if low_change <= high_change %}
                {# The low setpoint changed less, so adjust it downward #}
                low:{{ high - 1 }};high:{{ high }}
              {% else %}
                {# The high setpoint changed less, so adjust it upward #}
                {% set new_high = ((low + 1) * 2) | round / 2 %}
                low:{{ low }};high:{{ new_high }}
              {% endif %}
            {% else %}
              low:{{ low }};high:{{ high }}
            {% endif %}

      - variables:
          # Extract adjusted values using string parsing
          adjusted_low: >-
            {% set parts = final_calculation.split(';') %}
            {% set low_part = parts[0].split(':') %}
            {{ low_part[1]|float }}
          adjusted_high: >-
            {% set parts = final_calculation.split(';') %}
            {% set high_part = parts[1].split(':') %}
            {{ high_part[1]|float }}
          new_target_low: "{{ adjusted_low }}"
          new_target_high: "{{ adjusted_high }}"

      # Switches HVAC mode if necessary
      - choose:
          - conditions: "{{ allow_mode_switch_input and thermostat_mode != 'heat_cool' and needed_mode != thermostat_mode and needed_mode in ['heat','cool'] }}"
            sequence:
              - service: climate.set_hvac_mode
                target:
                  entity_id: !input thermostat
                data:
                  hvac_mode: "{{ needed_mode }}"
      # Adjusts temperature setpoints for the current mode, without weather adjustments.
      - choose:
          - conditions:
              - "{{ thermostat_mode == 'heat_cool' }}"
              - "{{ new_target_low != current_target_low or new_target_high != current_target_high }}"
            sequence:
              - condition: template
                value_template: "{{ new_target_low >= safety_min and new_target_high <= safety_max and new_target_low < new_target_high }}"
              - service: climate.set_temperature
                target:
                  entity_id: !input thermostat
                data:
                  target_temp_low: "{{ new_target_low }}"
                  target_temp_high: "{{ new_target_high }}"
          - conditions:
              - "{{ thermostat_mode in ['heat', 'cool'] }}"
              - "{{ offset_adjustment != 0 }}"
            sequence:
              - variables:
                  new_target_single: "{{ ((current_target_single + offset_adjustment) * 2) | round / 2 }}"
              - condition: template
                value_template: "{{ new_target_single >= safety_min and new_target_single <= safety_max }}"
              - service: climate.set_temperature
                target:
                  entity_id: !input thermostat
                data:
                  temperature: "{{ new_target_single }}"

  # Ensures the fan mode is enforced (useful for ERV/HRV setups)
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ enforce_fan_mode_input }}"
          - condition: template
            value_template: "{{ state_attr(thermostat_entity, 'fan_mode') not in [desired_fan_mode] }}"
        sequence:
          - delay: "00:01:00"   # avoid API spam if previous services run back-to-back
          - service: climate.set_fan_mode
            target:
              entity_id: !input thermostat
            data:
              fan_mode: "{{ desired_fan_mode }}"

  # Debug message is now the last action in the automation
  - choose:
      - conditions: "{{ debug_notifications_enabled }}"
        sequence:
          - service: persistent_notification.create
            data:
              title: "Smart Thermostat DEBUG {{ 'ON' if is_weather_available else 'OFF' }}"
              message: |-
                **Current Status**
                â€¢ Room: {{ current_target_temp }}Â°C | Target: {{ desired_temp }}Â°C | Î”{{ '{:+.1f}'.format(temp_difference) }}Â°C
                â€¢ HVAC: {{ thermostat_mode }} ({{ current_target_low }}Â°C - {{ current_target_high }}Â°C)

                **Analysis**
                â€¢ {{ debug_adjustment_reason }}
                â€¢ Natural trend: {{ natural_thermal_trend }}

                {% if is_weather_available %}
                **Weather Factors**
                â€¢ Solar: {{ '{:+.1f}'.format(debug_solar_impact|float) }}Â°C
                â€¢ Trend: {{ '{:+.1f}'.format(debug_trend_impact|float) }}Â°C
                â€¢ **Total Effect:** {{ '{:+.1f}'.format(weather_effect|float) }}Â°C
                {% endif %}

                {% set low_change = new_target_low|float - current_target_low|float %}
                {% set high_change = new_target_high|float - current_target_high|float %}
                **Action Taken**
                {% if low_change != 0 or high_change != 0 %}
                â€¢ Heat setpoint: {{ '{:+.1f}'.format(low_change) }}Â°C â†’ {{ new_target_low }}Â°C
                â€¢ Cool setpoint: {{ '{:+.1f}'.format(high_change) }}Â°C â†’ {{ new_target_high }}Â°C
                {% else %}
                â€¢ No adjustment needed - room within target range
                {% endif %}

variables:
  # --- VARIABLE DEFINITIONS ---
  # This section defines all the variables used throughout the automation for clarity and reusability.
  #
  # PERFORMANCE OPTIMIZATIONS (v1.12.0):
  # - Broken down monolithic templates into smaller, testable components
  # - Pre-calculated weather factors to avoid redundant calculations
  # - Simplified debug notifications to reduce Android tablet load
  # - Cached complex calculations in dedicated variables
  # Aliases for blueprint inputs to make templates cleaner.
  day_target_sensor_entity: !input day_target_sensor
  night_target_sensor_entity: !input night_target_sensor
  thermostat_entity: !input thermostat
  day_temp_input_entity: !input day_temp_input
  night_temp_input_entity: !input night_temp_input
  use_day_temp_input: !input use_day_temp_input
  use_night_temp_input: !input use_night_temp_input
  day_temp_static: !input day_temp_static
  night_temp_static: !input night_temp_static
  day_start_hour: !input day_sensor_start_hour
  night_start_hour: !input night_sensor_start_hour
  sensor_timeout_hours: !input sensor_timeout
  min_temp_limit_value: !input min_temp_limit
  max_temp_limit_value: !input max_temp_limit
  weather_entity: !input weather_entity
  outdoor_temp_sensor_input: !input outdoor_temp_sensor
  use_outdoor_temp_sensor_input: !input use_outdoor_temp_sensor
  outdoor_temp_entity: >
    {% if use_outdoor_temp_sensor_input and outdoor_temp_sensor_input != "" %}
      {{ outdoor_temp_sensor_input }}
    {% else %}
      ""
    {% endif %}


  enforce_fan_mode_input: !input enforce_fan_mode
  fan_mode_setting_input: !input fan_mode_setting
  desired_fan_mode: "{{ fan_mode_setting_input if fan_mode_setting_input | length > 0 else 'low' }}"
  use_weather_forecast_input: !input use_weather_forecast
  debug_notifications_enabled: !input debug_notifications
  forecast_adjustment_value: !input forecast_adjustment
  solar_adjustment_value: !input solar_adjustment
  gradient_threshold_value: !input gradient_threshold
  circadian_hour_value: !input circadian_hour

  # Safety setpoint limits from blueprint inputs.
  safety_min: !input safety_min_setpoint
  safety_max: !input safety_max_setpoint

  # Determines if the weather feature should be used.
  # Checks if the toggle is enabled, an entity is provided, and the entity is not in an error state.
  is_weather_available: "{{ use_weather_forecast_input and weather_entity != none and weather_entity|length > 0 and states(weather_entity) not in ['unavailable', 'unknown', 'none'] }}"

  # Dynamically selects the active temperature sensor (day or night) based on the current time
  # and the configured start hours for day and night periods.
  current_target_sensor_entity: >
    {% set hour = now().hour %}
    {% set day_start = day_start_hour | int %}
    {% set night_start = night_start_hour | int %}
    {% if day_start < night_start %}
      {# Normal case: day_start=6, night_start=22 -> day sensor 6-21, night sensor 22-5 #}
      {% if hour >= day_start and hour < night_start %}
        {{ day_target_sensor_entity }}
      {% else %}
        {{ night_target_sensor_entity }}
      {% endif %}
    {% else %}
      {# Edge case: night_start < day_start (e.g., day_start=22, night_start=6) #}
      {% if hour >= night_start and hour < day_start %}
        {{ night_target_sensor_entity }}
      {% else %}
        {{ day_target_sensor_entity }}
      {% endif %}
    {% endif %}

  # Fetches the target temperatures from either helpers or fixed values based on the toggle.
  day_temp: >
    {% if use_day_temp_input and day_temp_input_entity != "" %}
      {{ states(day_temp_input_entity) | float(24) }}
    {% else %}
      {{ day_temp_static | float(24) }}
    {% endif %}

  night_temp: >
    {% if use_night_temp_input and night_temp_input_entity != "" %}
      {{ states(night_temp_input_entity) | float(20) }}
    {% else %}
      {{ night_temp_static | float(20) }}
    {% endif %}

  # Gets the current hour as a float (e.g., 18.5 for 6:30 PM) for use in calculations.
  current_hour: "{{ now().hour + (now().minute / 60.0) }}"

  # Calculates the "desired" temperature at any given moment using a cosine curve.
  # This simulates a natural circadian rhythm with the coolest temperature at the selected AM hour
  # and warmest at the same PM hour (12 hours later).
  desired_temp: >
    {% set dtemp = day_temp %}
    {% set ntemp = night_temp %}
    {% set hour = now().hour + (now().minute / 60.0) %}
    {% set temp_range = dtemp - ntemp %}
    {% set coolest_hour = circadian_hour_value | int %}
    {% if coolest_hour == 0 %}
      {% set coolest_hour = 0 %}
    {% endif %}

    {# Create smooth curve: coolest at the selected AM hour, warmest 12 hours later #}
    {% set phase = (hour - coolest_hour) * 15 %}  {# Convert to degrees (24h = 360Â°) #}
    {% set curve = (1 - cos(phase | float * 3.14159 / 180)) / 2 %} {# Inverted curve #}
    {% set dynamic_temp = ntemp + (temp_range * curve) %}

    {{ dynamic_temp | round(1) }}

  # Core temperature and thermostat state variables.
  current_target_temp: "{{ states(current_target_sensor_entity) | float(22) }}"
  thermostat_mode: "{{ states(thermostat_entity) }}"
  hvac_action: "{{ state_attr(thermostat_entity, 'hvac_action') }}"
  # The difference between the room's current temperature and the calculated desired temperature.
  temp_difference: "{{ (current_target_temp - desired_temp) | round(1) }}"
  # Current temperature setpoints from the thermostat.
  current_target_low: "{{ state_attr(thermostat_entity, 'target_temp_low') | float(22) }}"
  current_target_high: "{{ state_attr(thermostat_entity, 'target_temp_high') | float(23) }}"
  current_target_single: "{{ state_attr(thermostat_entity, 'temperature') | float(22) }}"
  # Determines the required HVAC mode (heat, cool, or heat_cool) based on the temperature difference.
  # It will suggest switching modes if the temperature is significantly off target (e.g., > 0.7Â°C)
  # to prevent rapid cycling between heating and cooling.
  needed_mode: >
    {% set diff = temp_difference %}
    {% if thermostat_mode == 'heat_cool' %}
      heat_cool
    {% elif thermostat_mode == 'heat' and diff > 0.7 %}
      cool
    {% elif thermostat_mode == 'cool' and diff < -0.7 %}
      heat
    {% else %}
      {{ thermostat_mode }}
    {% endif %}
  # Calculates an adaptive temperature offset following hierarchical priority rules:
  # 1. ABSOLUTE BOUNDS (always enforced): night_temp â‰¤ room_temp â‰¤ day_temp
  # 2. COMFORT TOLERANCE (normal operation): circadian_target Â± 0.5Â°C
  # Nudges are Â±0.5 Â°C at most per cycle for stability
  offset_adjustment: >
    {# ABSOLUTE BOUNDS CHECK (CRITICAL) - Always enforced first #}
    {% if current_target_temp < night_temp %}
      {# Room too cold - violates minimum comfort bound - immediate heating needed #}
      0.5
    {% elif current_target_temp > day_temp %}
      {# Room too hot - violates maximum comfort bound - immediate cooling needed #}
      -0.5
    {% else %}
      {# Within absolute bounds - apply comfort tolerance around circadian target #}
      {% set low_band = desired_temp - 0.5 %}
      {% set high_band = desired_temp + 0.5 %}

      {% if current_target_temp < low_band %}
        0.5
      {% elif current_target_temp > high_band %}
        -0.5
      {% else %}
        0
      {% endif %}
    {% endif %}

  # Variable for consolidated sensor validation logic
  sensors_valid: >
    {% set day_s = day_target_sensor_entity %}
    {% set night_s = night_target_sensor_entity %}
    {% set day_state = states[day_s] %}
    {% set night_state = states[night_s] %}
    {% set thermo_state = states[thermostat_entity] %}
    {% set timeout_seconds = sensor_timeout_hours * 3600 %}

    {% if day_state is none or day_state.state in ['unknown', 'unavailable', 'none'] or
          night_state is none or night_state.state in ['unknown', 'unavailable', 'none'] or
          thermo_state is none or thermo_state.state in ['unknown', 'unavailable', 'none'] %}
      false
    {% else %}
      {% set day_temp = day_state.state | float(-99) %}
      {% set night_temp = night_state.state | float(-99) %}

      {% set temp_valid = day_temp >= min_temp_limit_value and
                          night_temp >= min_temp_limit_value and
                          day_temp <= max_temp_limit_value and
                          night_temp <= max_temp_limit_value %}

      {% set sensors_fresh = (now() - day_state.last_updated).total_seconds() < timeout_seconds and
                             (now() - night_state.last_updated).total_seconds() < timeout_seconds %}
      {% set thermo_fresh = (now() - thermo_state.last_updated).total_seconds() < timeout_seconds %}
      {{ temp_valid and sensors_fresh and thermo_fresh }}
    {% endif %}



  allow_mode_switch_input: !input allow_mode_switch

  # --- SETPOINT CALCULATION COMPONENTS ---
  # Simplified components for easier testing and maintenance

  # Calculate desired temperature band boundaries
  desired_temp_band_low: "{{ ((desired_temp - 0.5) * 2) | round / 2 }}"
  desired_temp_band_high: "{{ ((desired_temp + 0.5) * 2) | round / 2 }}"

  # Safety-bounded temperature limits
  effective_min_temp: "{{ [desired_temp_band_low, night_temp, safety_min] | max }}"
  effective_max_temp: "{{ [desired_temp_band_high, day_temp, safety_max] | min }}"

  # Temperature adjustment decision logic - hierarchical priority
  violates_min_bound: "{{ current_target_temp < night_temp }}"
  violates_max_bound: "{{ current_target_temp > day_temp }}"
  needs_heating_adjustment: "{{ current_target_temp < (desired_temp - 0.5) }}"
  needs_cooling_adjustment: "{{ current_target_temp > (desired_temp + 0.5) }}"

  # Rate-limited adjustment calculation following priority rules
  base_adjustment_amount: >
    {% if violates_min_bound %}
      0.5
    {% elif violates_max_bound %}
      -0.5
    {% elif needs_heating_adjustment %}
      0.5
    {% elif needs_cooling_adjustment %}
      -0.5
    {% else %}
      0
    {% endif %}

  # --- WEATHER CALCULATION COMPONENTS ---
  # Break down complex weather logic into testable components for Android tablet performance

  # Solar impact calculation - simplified and cached
  solar_impact_factor: >
    {% if is_weather_available %}
      {% set condition = state_attr(weather_entity, 'condition') %}
      {% set hour = now().hour %}
      {% set is_daytime = 6 <= hour <= 18 %}
      {% if is_daytime and condition in ['sunny', 'partlycloudy'] %}
        {{ solar_adjustment_value|float if condition == 'sunny' else (solar_adjustment_value|float * 0.5) }}
      {% else %}
        0
      {% endif %}
    {% else %}
      0
    {% endif %}



  # Temperature gradient analysis - simplified logic
  indoor_outdoor_gradient: >
    {% if is_weather_available %}
      {% set outdoor = current_outdoor_temp|default(desired_temp)|float %}
      {% set indoor = current_target_temp|float %}
      {{ (indoor - outdoor)|round(1) }}
    {% else %}
      0
    {% endif %}

  # Natural trend determination - cleaner logic
  natural_thermal_trend: >
    {% if is_weather_available %}
      {% set gradient = indoor_outdoor_gradient|float %}
      {% set solar = solar_impact_factor|float %}
      {% if gradient < -gradient_threshold_value and solar < 0.3 %}
        warming
      {% elif gradient > gradient_threshold_value and solar == 0 %}
        cooling
      {% elif solar > 0.3 %}
        warming
      {% else %}
        stable
      {% endif %}
    {% else %}
      stable
    {% endif %}

  # Combined weather adjustment - aggregated result
  weather_effect: "{{ weather_adjustment_for_range|default(0)|float }}"
  adjusted_current_temp: "{{ (current_target_temp|float + weather_effect|float)|round(1) }}"
  aggregated_desired_temp: "{{ (desired_temp|float + weather_effect|float)|round(1) }}"
  # --- DEBUG DISPLAY COMPONENTS ---
  # Simplified debug values for better Android tablet performance

  # Use pre-calculated values instead of recalculating
  debug_solar_impact: "{{ solar_impact_factor|default(0)|round(1) }}"
  debug_trend_impact: "{{ (weather_effect|float - debug_solar_impact|float)|round(1) }}"

  # Status indicators with hierarchical reasoning
  debug_adjustment_reason: >
    {% if violates_min_bound %}
      Room below minimum bound ({{ current_target_temp }}Â°C < {{ night_temp }}Â°C night_temp)
    {% elif violates_max_bound %}
      Room above maximum bound ({{ current_target_temp }}Â°C > {{ day_temp }}Â°C day_temp)
    {% elif needs_heating_adjustment %}
      Room below comfort zone ({{ current_target_temp }}Â°C < {{ (desired_temp - 0.5)|round(1) }}Â°C)
    {% elif needs_cooling_adjustment %}
      Room above comfort zone ({{ current_target_temp }}Â°C > {{ (desired_temp + 0.5)|round(1) }}Â°C)
    {% else %}
      Room within target range
    {% endif %}

  desired_temp_plus1h: >
    {% set hour = (now() + timedelta(hours=1)).hour
       + ((now() + timedelta(hours=1)).minute / 60.0) %}
    {% set dtemp = day_temp %}
    {% set ntemp = night_temp %}
    {% set temp_range = dtemp - ntemp %}
    {% set coolest_hour = circadian_hour_value | int %}
    {% if coolest_hour == 0 %}
      {% set coolest_hour = 0 %}
    {% endif %}

    {# Create smooth curve: coolest at the selected AM hour, warmest 12 hours later #}
    {% set phase = (hour - coolest_hour) * 15 %}  {# Convert to degrees (24h = 360Â°) #}
    {% set curve = (1 - cos(phase | float * 3.14159 / 180)) / 2 %} {# Inverted curve #}
    {% set dynamic_temp = ntemp + (temp_range * curve) %}

    {{ dynamic_temp | round(1) }}

  # New variable for projected room temperature one hour from now
  projected_room_plus1h: >
    {# Simple projection: assume room will drift by Â±0.2 Â°C depending on natural_trend #}
    {% if natural_trend == 'warming' %}
      {{ (current_target_temp + 0.2)|round(1) }}
    {% elif natural_trend == 'cooling' %}
      {{ (current_target_temp - 0.2)|round(1) }}
    {% else %}
      {{ current_target_temp }}
    {% endif %}

  aggregated_desired_plus1h: "{{ (desired_temp_plus1h|float + weather_effect|float)|round(1) }}"
  delta_desired_1h: "{{ (aggregated_desired_plus1h|float - aggregated_desired_temp|float)|round(1) }}"

  future_delta: "{{ (projected_room_plus1h|float - aggregated_desired_plus1h|float)|round(1) }}"
