blueprint:
  name: Smart Thermostat with Day/Night Sensors
  description: |
    **Version: 1.9.0**

    Smart single-zone thermostat brain for Home Assistant.

    WHAT IT DOES
    • Chooses a *Day* or *Night* room sensor automatically by the clock.
    • Glides between your Day and Night target temps using a smooth circadian curve.
    • Every 60 min decides whether to Heat, Cool or Heat-Cool and gently nudges the set-points toward the target.
    • Can factor in outdoor weather/temperature, indoor humidity and solar impact to anticipate natural trends and save energy.
    • Keeps the fan from ever being 'off' (great for ERV/HRV systems).

    HOW TO USE
    1. Pick your Day & Night sensors.
    2. Choose whether each target temp comes from an *input_number* helper or a fixed value.
    3. Set the hours when each sensor becomes active (e.g. Day 06:00, Night 22:00).
    4. (Optional) Toggle weather, outdoor-temp sensor or humidity sensor support and tune the adjustment factors.
    5. Turn on *Debug Notifications* to see a step-by-step breakdown in Home Assistant.

    SAFETY FIRST
    • Automation aborts if any sensor/thermostat data is stale, unknown or outside your min/max limits and explains why.
    • All set-points are clamped between the safety min/max values you define.

    Zero YAML edits required—everything is configurable via the blueprint UI.

  domain: automation

  input:
    day_target_sensor:
      name: Day Target Temperature Sensor
      description: Temperature sensor to use during daytime hours (e.g., living room)
      selector:
        entity:
          filter:
            domain: sensor

    night_target_sensor:
      name: Night Target Temperature Sensor
      description: Temperature sensor to use during nighttime hours (e.g., bedroom)
      selector:
        entity:
          filter:
            domain: sensor

    thermostat:
      name: Thermostat
      description: Climate entity to control
      selector:
        entity:
          filter:
            domain: climate

    day_temp_input:
      name: Day Target Temperature
      description: Input number for daytime target temperature
      selector:
        entity:
          filter:
            domain: input_number

    night_temp_input:
      name: Night Target Temperature
      description: Input number for nighttime target temperature
      selector:
        entity:
          filter:
            domain: input_number

    # --- DAY & NIGHT TARGET TEMPERATURE MODE TOGGLES ---
    use_day_temp_input:
      name: Use Day Temperature Helper
      description: Enable to read the daytime target from an input_number helper. Disable to use the fixed value below.
      selector:
        boolean:
      default: true

    day_temp_static:
      name: Day Target Temperature (Fixed)
      description: Fixed daytime target temperature when helper is disabled
      default: 22
      selector:
        number:
          min: 10
          max: 35
          step: 0.5
          unit_of_measurement: "°C"

    use_night_temp_input:
      name: Use Night Temperature Helper
      description: Enable to read the nighttime target from an input_number helper. Disable to use the fixed value below.
      selector:
        boolean:
      default: true

    night_temp_static:
      name: Night Target Temperature (Fixed)
      description: Fixed nighttime target temperature when helper is disabled
      default: 20
      selector:
        number:
          min: 10
          max: 35
          step: 0.5
          unit_of_measurement: "°C"

    day_sensor_start_hour:
      name: Day Sensor Start Hour
      description: Hour to switch to day sensor (24-hour format)
      default: 6
      selector:
        number:
          min: 0
          max: 23
          step: 1
          unit_of_measurement: hour

    night_sensor_start_hour:
      name: Night Sensor Start Hour
      description: Hour to switch to night sensor (24-hour format)
      default: 22
      selector:
        number:
          min: 0
          max: 23
          step: 1
          unit_of_measurement: hour

    sensor_timeout:
      name: Sensor Timeout (hours)
      description: Skip automation if sensor hasn't updated within this many hours
      default: 2
      selector:
        number:
          min: 0.5
          max: 6
          step: 0.5
          unit_of_measurement: hours

    min_temp_limit:
      name: Minimum Temperature Limit
      description: Skip if sensor reads below this temperature (°C)
      default: 10
      selector:
        number:
          min: 0
          max: 15
          step: 1
          unit_of_measurement: °C

    max_temp_limit:
      name: Maximum Temperature Limit
      description: Skip if sensor reads above this temperature (°C)
      default: 35
      selector:
        number:
          min: 25
          max: 50
          step: 1
          unit_of_measurement: °C

    use_weather_forecast:
      name: Use Weather Forecast
      description: Enable to use weather forecast data for predictive adjustments.
      selector:
        boolean:
      default: false

    debug_notifications:
      name: Enable Debug Notifications
      description: If enabled, creates a persistent notification with debug data on each run.
      selector:
        boolean:
      default: false

    weather_entity:
      name: Weather Entity
      description: Optional weather entity to use for forecasting natural heating/cooling (leave blank to disable)
      selector:
        entity:
          filter:
            domain: weather

    outdoor_temp_sensor:
      name: Outdoor Temperature Sensor
      description: Optional real-time outdoor temperature sensor (more accurate than weather forecast)
      selector:
        entity:
          filter:
            domain: sensor
      default: ""

    humidity_sensor:
      name: Indoor Humidity Sensor
      description: Optional humidity sensor for "feels like" temperature calculations
      selector:
        entity:
          filter:
            domain: sensor
      default: ""

    use_outdoor_temp_sensor:
      name: Use Outdoor Temperature Sensor
      description: Enable to include the outdoor temperature sensor in calculations.
      selector:
        boolean:
      default: false

    use_humidity_sensor:
      name: Use Humidity Sensor
      description: Enable to include the indoor humidity sensor in calculations.
      selector:
        boolean:
      default: false

    solar_adjustment:
      name: Solar Impact Factor
      description: Adjustment factor for direct sunlight impact (higher = stronger impact)
      default: 0.5
      selector:
        number:
          min: 0.1
          max: 1.0
          step: 0.1
          unit_of_measurement: factor

    forecast_adjustment:
      name: Forecast Adjustment
      description: Temperature adjustment value (°C) to apply when using weather forecast for predictive control
      default: 0.3
      selector:
        number:
          min: 0.1
          max: 1.0
          step: 0.1
          unit_of_measurement: "°C"

    gradient_threshold:
      name: Gradient Threshold
      description: Temperature difference (°C) between indoor and outdoor needed to identify warming/cooling trends
      default: 2.0
      selector:
        number:
          min: 0.5
          max: 5.0
          step: 0.5
          unit_of_measurement: "°C"

    circadian_hour:
      name: Circadian Rhythm Time
      description: Set when temperatures are coolest (AM) and warmest (PM). Value 0=12AM/12PM, 1=1AM/1PM, etc.
      default: 4
      selector:
        number:
          min: 0
          max: 11
          step: 1
          mode: slider

    safety_min_setpoint:
      name: Safety Minimum Setpoint
      description: The minimum allowable temperature setpoint for the thermostat (°C). Prevents setting temperatures that are too low.
      default: 18
      selector:
        number:
          min: 15
          max: 22
          step: 1
          unit_of_measurement: "°C"

    safety_max_setpoint:
      name: Safety Maximum Setpoint
      description: The maximum allowable temperature setpoint for the thermostat (°C). Prevents setting temperatures that are too high.
      default: 28
      selector:
        number:
          min: 23
          max: 32
          step: 1
          unit_of_measurement: "°C"

    # --- FAN MODE ENFORCEMENT ---
    enforce_fan_mode:
      name: Enforce Fan Mode
      description: Ensure the thermostat fan is set to a specific mode after every run.
      selector:
        boolean:
      default: true

    fan_mode_setting:
      name: Fan Mode to Enforce
      description: Fan mode that will be applied when enforcement is enabled.
      selector:
        select:
          options:
            - "low"
            - "medium"
            - "high"
            - "on"
            - "auto"
      default: "low"

alias: Smart Thermostat - Auto Mode Switching
description: >-
  Single temperature control with automatic heating/cooling mode switching based
  on bedroom temperature
triggers:
  # This automation runs every 30 minutes to re-evaluate the thermostat settings.
  - trigger: time_pattern
    hours: /1
conditions:
  # --- PRE-EXECUTION CHECKS ---
  # Ensures the automation doesn't run if the thermostat is manually turned off.
  - condition: not
    conditions:
      - condition: state
        entity_id: !input thermostat
        state: "off"
  # Skips execution if the thermostat is in 'away' or 'vacation' mode.
  - condition: not
    conditions:
      - condition: or
        conditions:
          - condition: state
            entity_id: !input thermostat
            attribute: preset_mode
            state: "away"
          - condition: state
            entity_id: !input thermostat
            attribute: preset_mode
            state: "vacation"
  # Only runs automation if thermostat is in a temperature control mode (heat, cool, or heat_cool)
  - condition: template
    value_template: "{{ states(thermostat_entity) in ['heat', 'cool', 'heat_cool'] }}"

actions:
  # Early safety check – aborts execution (with optional debug) if sensor validation fails
  - choose:
      - conditions: "{{ not sensors_valid }}"
        sequence:
          - choose:
              - conditions: "{{ debug_notifications_enabled }}"
                sequence:
                  - service: persistent_notification.create
                    data:
                      title: "🛡️ Smart Thermostat Safety Check Failed"
                      message: |-
                        **Automation skipped due to sensor validation failure.**

                        **Current Readings:**
                        • Day sensor: {{ states(day_target_sensor_entity) }} °C ({{ day_target_sensor_entity }})
                        • Night sensor: {{ states(night_target_sensor_entity) }} °C ({{ night_target_sensor_entity }})
                        • Thermostat: {{ state_attr(thermostat_entity, 'current_temperature') | default('unknown') }} °C ({{ thermostat_entity }})

                        **Data Freshness:**
                        • Day sensor: {{ ((now() - states[day_target_sensor_entity].last_updated).total_seconds() / 60) | round(1) }} minutes ago
                        • Night sensor: {{ ((now() - states[night_target_sensor_entity].last_updated).total_seconds() / 60) | round(1) }} minutes ago
                        • Thermostat: {{ ((now() - states[thermostat_entity].last_updated).total_seconds() / 60) | round(1) }} minutes ago
                        • **Timeout limit:** {{ sensor_timeout_hours }} hours ({{ (sensor_timeout_hours * 60) | round(0) }} minutes)

                        **Temperature Limits:** {{ min_temp_limit_value }} – {{ max_temp_limit_value }} °C

                        {% set day_age_minutes = ((now() - states[day_target_sensor_entity].last_updated).total_seconds() / 60) %}
                        {% set night_age_minutes = ((now() - states[night_target_sensor_entity].last_updated).total_seconds() / 60) %}
                        {% set thermostat_age_minutes = ((now() - states[thermostat_entity].last_updated).total_seconds() / 60) %}
                        {% set timeout_minutes = sensor_timeout_hours * 60 %}
                        {% if day_age_minutes > timeout_minutes or night_age_minutes > timeout_minutes or thermostat_age_minutes > timeout_minutes %}
                        **Issue:** Sensor data is stale (older than {{ (sensor_timeout_hours * 60) | round(0) }} minutes)
                        **Solution:** Check sensor connectivity or increase timeout in blueprint settings
                        {% else %}
                        **Issue:** Temperature readings outside valid range
                        **Solution:** Check sensor calibration or adjust temperature limits
                        {% endif %}

                        **Note:** If you are using an *average* or *statistics* sensor, its `last_updated` timestamp only updates when the calculated value changes. When the temperature is stable, this can make a healthy sensor look stale. If this is the case, consider increasing the *Sensor Timeout* in the blueprint settings or switch to a raw sensor for freshness checks.
          - stop: "Safety check failed – automation halted"

  # Weather-enabled path
  - choose:
      - conditions: "{{ is_weather_available }}"
        sequence:
          # --- WEATHER ENABLED PATH ---
          # This block executes when weather integration is active.
          # Fetches the hourly weather forecast. The response is stored in 'weather_forecast'.
          - service: weather.get_forecasts
            target:
              entity_id: "{{ weather_entity }}"
            data:
              type: hourly
            response_variable: weather_forecast
          - variables:
              # Extract forecast data from the weather response for use in multiple places
              forecast_data: >
                {% if weather_forecast is defined and weather_entity in weather_forecast and 'forecast' in weather_forecast[weather_entity] and weather_forecast[weather_entity].forecast|length >= 1 %}
                  {{ weather_forecast[weather_entity].forecast }}
                {% else %}
                  []
                {% endif %}

              # Determine the current outdoor temperature, preferring the real sensor if available
              current_outdoor_temp: >
                {% if outdoor_temp_entity != "" and states(outdoor_temp_entity) not in ['unknown', 'unavailable', 'none'] %}
                  {{ states(outdoor_temp_entity) | float }}
                {% elif forecast_data|length >= 1 %}
                  {{ forecast_data[0].temperature|float }}
                {% else %}
                  {{ states(weather_entity).attributes.temperature|default(20)|float }}
                {% endif %}

              # Get the current weather condition from the forecast
              current_condition: >
                {% if forecast_data|length >= 1 %}
                  {{ forecast_data[0].condition }}
                {% else %}
                  {{ states(weather_entity).attributes.condition|default('unknown') }}
                {% endif %}

              # Calculate solar impact based on weather condition and time of day
              solar_impact: >
                {% set hour = now().hour %}
                {% set is_daytime = hour >= 6 and hour <= 18 %}
                {% set sunny_conditions = ['sunny', 'partlycloudy'] %}
                {% set partial_conditions = ['partlycloudy', 'cloudy'] %}

                {% if is_daytime and current_condition in sunny_conditions %}
                  {% if current_condition == 'sunny' %}
                    {{ solar_adjustment_value }}
                  {% elif current_condition == 'partlycloudy' %}
                    {{ solar_adjustment_value * 0.5 }}
                  {% else %}
                    0
                  {% endif %}
                {% else %}
                  0
                {% endif %}

              # Calculate "feels like" temperature if humidity sensor is available
              feels_like_temp: >
                {% if humidity_entity != "" and states(humidity_entity) not in ['unknown', 'unavailable', 'none'] %}
                  {% set humidity = states(humidity_entity) | float %}
                  {% set actual_temp = current_target_temp %}

                  {% if actual_temp >= 20 %}
                    {# Heat index calculation - high temp + high humidity feels warmer #}
                    {% if humidity > 40 %}
                      {% set humidity_factor = (humidity - 40) / 100 %}
                      {# Increased coefficient from 0.5 to 0.8 for more pronounced effect #}
                      {% set feels_like_adjustment = humidity_factor * (actual_temp - 19) * 0.8 %}
                      {{ actual_temp + feels_like_adjustment }}
                    {% elif humidity < 30 %}
                      {# Dry air can feel slightly cooler than actual temperature #}
                      {% set dry_factor = (30 - humidity) / 100 %}
                      {% set feels_like_adjustment = dry_factor * 0.5 %}
                      {{ actual_temp - feels_like_adjustment }}
                    {% else %}
                      {{ actual_temp }}
                    {% endif %}
                  {% elif actual_temp <= 18 %}
                    {# Wind chill approximation - high humidity makes cold feel colder #}
                    {% if humidity > 60 %}
                      {% set humidity_factor = (humidity - 60) / 100 %}
                      {% set feels_like_adjustment = humidity_factor * 0.8 %}
                      {{ actual_temp - feels_like_adjustment }}
                    {% else %}
                      {{ actual_temp }}
                    {% endif %}
                  {% else %}
                    {{ actual_temp }}
                  {% endif %}
                {% else %}
                  {{ current_target_temp }}
                {% endif %}

              # Get the current humidity for use in calculations and debug output
              current_humidity: >
                {% if humidity_entity != "" and states(humidity_entity) not in ['unknown', 'unavailable', 'none'] %}
                  {{ states(humidity_entity) | float }}
                {% else %}
                  unknown
                {% endif %}

              # Determine the thermal contribution of the building envelope
              # This considers wall thermal mass effects based on outdoor temperature trends
              building_thermal_contribution: >
                {% if forecast_data|length >= 3 %}
                  {% set now_temp = current_outdoor_temp %}
                  {% set prev_temp = forecast_data[1].temperature|float %}
                  {% set trend_strength = (now_temp - prev_temp)|abs %}

                  {% if trend_strength > 1 %}
                    {% if now_temp > prev_temp %}
                      warming
                    {% else %}
                      cooling
                    {% endif %}
                  {% else %}
                    stable
                  {% endif %}
                {% else %}
                  stable
                {% endif %}

              # Comprehensive natural thermal trend that considers:
              # 1. Indoor/outdoor gradient
              # 2. Solar impact
              # 3. Building thermal mass
              # 4. Feels like temperature
              # 5. Forecast trend (if available)
              natural_trend: >
                {% set temp_gradient = desired_temp - current_outdoor_temp %}
                {% set gradient_trend = 'unknown' %}
                {% set actual_indoor_outdoor_diff = current_target_temp - current_outdoor_temp %}

                {# Determine gradient trend based on indoor-outdoor difference #}
                {% if temp_gradient < -gradient_threshold_value %}
                  {% set gradient_trend = 'warming' %}
                {% elif temp_gradient > gradient_threshold_value %}
                  {% set gradient_trend = 'cooling' %}
                {% else %}
                  {% set gradient_trend = 'stable' %}
                {% endif %}

                {# Check forecast trends if available #}
                {% set forecast_trend = 'unknown' %}
                {% if forecast_data|length >= 3 %}
                  {% set current_temp = current_outdoor_temp %}
                  {% set future_temp = forecast_data[2].temperature|float %}
                  {% set trend_diff = future_temp - current_temp %}

                  {% if trend_diff > 1 %}
                    {% set forecast_trend = 'warming' %}
                  {% elif trend_diff < -1 %}
                    {% set forecast_trend = 'cooling' %}
                  {% else %}
                    {% set forecast_trend = 'stable' %}
                  {% endif %}
                {% endif %}

                {# Make final determination #}
                {% if actual_indoor_outdoor_diff < -2 and temp_gradient < 0 %}
                  {# If indoor is already >2°C cooler than outdoor, and desired is less than outdoor,
                     the space will likely warm up regardless of other factors #}
                  warming
                {% elif actual_indoor_outdoor_diff > 2 and temp_gradient > 0 %}
                  {# If indoor is already >2°C warmer than outdoor, and desired is greater than outdoor,
                     the space will likely cool down regardless of other factors #}
                  cooling
                {% elif solar_impact|float > 0.3 and forecast_trend != 'cooling' %}
                  {# Strong solar impact will cause warming unless forecast shows cooling #}
                  warming
                {% elif forecast_trend != 'unknown' %}
                  {# Trust forecast trend if available #}
                  {{ forecast_trend }}
                {% elif building_thermal_contribution == 'warming' and gradient_trend != 'cooling' %}
                  warming
                {% elif building_thermal_contribution == 'cooling' and gradient_trend != 'warming' %}
                  cooling
                {% else %}
                  {{ gradient_trend }}
                {% endif %}

              # A more nuanced adjustment calculation that considers all factors
              weather_adjustment_factor: >
                {% set base_factor = forecast_adjustment_value %}
                {% set solar_factor = solar_impact|float %}
                {% set feels_adjustment = 0 %}

                {% if feels_like_temp|float > current_target_temp|float + 0.5 %}
                  {% set feels_adjustment = 0.2 %}
                {% elif feels_like_temp|float < current_target_temp|float - 0.5 %}
                  {% set feels_adjustment = -0.2 %}
                {% endif %}

                {% if natural_trend == 'warming' %}
                  {# More conservative adjustment for warming trends to prevent over-cooling #}
                  {% set temp_diff = current_outdoor_temp|float - desired_temp|float %}
                  {% if temp_diff > 0 and temp_difference > 0 %}
                    {# Only make significant cooling adjustments if both outdoor temp is higher than desired
                       AND current indoor temp is above desired temp #}
                    {{ (base_factor + solar_factor + feels_adjustment) * -0.7 }}
                  {% elif temp_difference < 0 %}
                    {# If indoor temp is already below desired, don't make negative adjustments #}
                    {{ feels_adjustment }}
                  {% else %}
                    {# Minimal adjustment in other warming scenarios #}
                    {{ (base_factor + solar_factor + feels_adjustment) * -0.3 }}
                  {% endif %}
                {% elif natural_trend == 'cooling' %}
                  {% if temp_difference < 0 %}
                    {# If room is already cooler than desired in cooling trend, apply positive adjustment #}
                    {{ (base_factor + feels_adjustment) | abs }}
                  {% else %}
                    {{ base_factor - feels_adjustment }}
                  {% endif %}
                {% else %}
                  {{ feels_adjustment }}
                {% endif %}

              # Calculates a small temperature adjustment for single-setpoint modes (heat/cool).
              # It proactively adjusts the setpoint based on the indoor-outdoor temperature gradient
              natural_heat_cool_adjustment: >
                {% if natural_trend != 'unknown' and thermostat_mode in ['heat', 'cool'] %}
                  {% if natural_trend == 'warming' and thermostat_mode == 'cool' %} {{ weather_adjustment_factor }}
                  {% elif natural_trend == 'cooling' and thermostat_mode == 'heat' %} {{ weather_adjustment_factor|abs }}
                  {% else %} 0
                  {% endif %}
                {% else %} 0
                {% endif %}

              # Calculates a temperature adjustment for the heat/cool range mode.
              # Shifts the entire range up or down based on the natural trend.
              weather_adjustment_for_range: "{{ weather_adjustment_factor }}"

          # Calculate new target setpoints with directional adjustments
          - variables:
              # Calculate the new heating setpoint
              calculated_low: >-
                {% if offset_adjustment > 0 %}
                  {{ ((current_target_low + offset_adjustment|abs) * 2) | round / 2 }}
                {% elif temp_difference > 0.5 and natural_trend == 'warming' %}
                  {% if weather_adjustment_for_range|float < 0 %}
                    {{ ((current_target_low + weather_adjustment_for_range) * 2) | round / 2 }}
                  {% else %}
                    {{ current_target_low }}
                  {% endif %}
                {% else %}
                  {{ current_target_low }}
                {% endif %}

          - variables:
              # Calculate the new cooling setpoint
              calculated_high: >-
                {% if offset_adjustment < 0 %}
                  {{ ((current_target_high + offset_adjustment) * 2) | round / 2 }}
                {% elif temp_difference < -0.5 and natural_trend == 'cooling' %}
                  {% if weather_adjustment_for_range|float > 0 %}
                    {{ ((current_target_high + weather_adjustment_for_range) * 2) | round / 2 }}
                  {% else %}
                    {{ current_target_high }}
                  {% endif %}
                {% else %}
                  {{ current_target_high }}
                {% endif %}

          - variables:
              # Ensure minimum 1°C difference between setpoints by adjusting whichever setpoint changed less
              final_calculation: >-
                {% set low = calculated_low|float %}
                {% set high = calculated_high|float %}
                {% set low_change = (low - current_target_low|float)|abs %}
                {% set high_change = (high - current_target_high|float)|abs %}

                {% if (high - low) < 1 %}
                  {% if low_change <= high_change %}
                    {# The low setpoint changed less, so adjust it downward #}
                    low:{{ high - 1 }};high:{{ high }}
                  {% else %}
                    {# The high setpoint changed less, so adjust it upward #}
                    {% set new_high = ((low + 1) * 2) | round / 2 %}
                    low:{{ low }};high:{{ new_high }}
                  {% endif %}
                {% else %}
                  low:{{ low }};high:{{ high }}
                {% endif %}

          - variables:
              # Extract adjusted values using string parsing
              adjusted_low: >-
                {% set parts = final_calculation.split(';') %}
                {% set low_part = parts[0].split(':') %}
                {{ low_part[1]|float }}
              adjusted_high: >-
                {% set parts = final_calculation.split(';') %}
                {% set high_part = parts[1].split(':') %}
                {{ high_part[1]|float }}
              new_target_low: "{{ adjusted_low }}"
              new_target_high: "{{ adjusted_high }}"

          # Switches the HVAC mode if the calculated 'needed_mode' is different from the current mode.
          - choose:
              - conditions: "{{ needed_mode != thermostat_mode and needed_mode in ['heat', 'cool', 'heat_cool'] }}"
                sequence:
                  - service: climate.set_hvac_mode
                    target:
                      entity_id: !input thermostat
                    data:
                      hvac_mode: "{{ needed_mode }}"
          # Adjusts the temperature setpoints based on the current HVAC mode.
          - choose:
              # For 'heat_cool' mode, it sets the new low and high targets.
              - conditions:
                  - "{{ thermostat_mode == 'heat_cool' }}"
                  - "{{ offset_adjustment != 0 or weather_adjustment_for_range != 0 }}"
                  - "{{ new_target_low != current_target_low or new_target_high != current_target_high }}"
                sequence:
                  # Safety condition to ensure new setpoints are within a reasonable range.
                  - condition: template
                    value_template: "{{ new_target_low >= safety_min and new_target_high <= safety_max and new_target_low < new_target_high }}"
                  - service: climate.set_temperature
                    target:
                      entity_id: !input thermostat
                    data:
                      target_temp_low: "{{ new_target_low }}"
                      target_temp_high: "{{ new_target_high }}"
              # For 'heat' or 'cool' modes, it calculates and sets a new single target temperature.
              - conditions:
                  - "{{ thermostat_mode in ['heat', 'cool'] }}"
                  - "{{ offset_adjustment != 0 or natural_heat_cool_adjustment != 0 }}"
                sequence:
                  # Calculates the new single setpoint, including offset and weather adjustments,
                  # and rounds it to the nearest 0.5°.
                  - variables:
                      new_target_single: "{{ ((current_target_single + offset_adjustment + natural_heat_cool_adjustment) * 2) | round / 2 }}"
                  # Safety condition to ensure the new setpoint is within a reasonable range.
                  - condition: template
                    value_template: "{{ new_target_single >= safety_min and new_target_single <= safety_max }}"
                  - service: climate.set_temperature
                    target:
                      entity_id: !input thermostat
                    data:
                      temperature: "{{ new_target_single }}"
    default:
      # --- WEATHER DISABLED PATH ---
      # This block executes if the weather integration is disabled or no entity is provided.
      # The logic is a simplified version of the weather-enabled path, without weather adjustments.
      # Calculate new target setpoints with directional adjustments
      - variables:
          # Calculate the new heating setpoint
          calculated_low: >-
            {% if offset_adjustment > 0 %}
              {{ ((current_target_low + offset_adjustment|abs) * 2) | round / 2 }}
            {% else %}
              {{ current_target_low }}
            {% endif %}

      - variables:
          # Calculate the new cooling setpoint
          calculated_high: >-
            {% if offset_adjustment < 0 %}
              {{ ((current_target_high + offset_adjustment) * 2) | round / 2 }}
            {% else %}
              {{ current_target_high }}
            {% endif %}

      - variables:
          # Ensure minimum 1°C difference between setpoints by adjusting whichever setpoint changed less
          final_calculation: >-
            {% set low = calculated_low|float %}
            {% set high = calculated_high|float %}
            {% set low_change = (low - current_target_low|float)|abs %}
            {% set high_change = (high - current_target_high|float)|abs %}

            {% if (high - low) < 1 %}
              {% if low_change <= high_change %}
                {# The low setpoint changed less, so adjust it downward #}
                low:{{ high - 1 }};high:{{ high }}
              {% else %}
                {# The high setpoint changed less, so adjust it upward #}
                {% set new_high = ((low + 1) * 2) | round / 2 %}
                low:{{ low }};high:{{ new_high }}
              {% endif %}
            {% else %}
              low:{{ low }};high:{{ high }}
            {% endif %}

      - variables:
          # Extract adjusted values using string parsing
          adjusted_low: >-
            {% set parts = final_calculation.split(';') %}
            {% set low_part = parts[0].split(':') %}
            {{ low_part[1]|float }}
          adjusted_high: >-
            {% set parts = final_calculation.split(';') %}
            {% set high_part = parts[1].split(':') %}
            {{ high_part[1]|float }}
          new_target_low: "{{ adjusted_low }}"
          new_target_high: "{{ adjusted_high }}"

      # Switches HVAC mode if necessary
      - choose:
          - conditions: "{{ needed_mode != thermostat_mode and needed_mode in ['heat', 'cool', 'heat_cool'] }}"
            sequence:
              - service: climate.set_hvac_mode
                target:
                  entity_id: !input thermostat
                data:
                  hvac_mode: "{{ needed_mode }}"
      # Adjusts temperature setpoints for the current mode, without weather adjustments.
      - choose:
          - conditions:
              - "{{ thermostat_mode == 'heat_cool' }}"
              - "{{ new_target_low != current_target_low or new_target_high != current_target_high }}"
            sequence:
              - condition: template
                value_template: "{{ new_target_low >= safety_min and new_target_high <= safety_max and new_target_low < new_target_high }}"
              - service: climate.set_temperature
                target:
                  entity_id: !input thermostat
                data:
                  target_temp_low: "{{ new_target_low }}"
                  target_temp_high: "{{ new_target_high }}"
          - conditions:
              - "{{ thermostat_mode in ['heat', 'cool'] }}"
              - "{{ offset_adjustment != 0 }}"
            sequence:
              - variables:
                  new_target_single: "{{ ((current_target_single + offset_adjustment) * 2) | round / 2 }}"
              - condition: template
                value_template: "{{ new_target_single >= safety_min and new_target_single <= safety_max }}"
              - service: climate.set_temperature
                target:
                  entity_id: !input thermostat
                data:
                  temperature: "{{ new_target_single }}"

  # Ensures the fan mode is enforced (useful for ERV/HRV setups)
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ enforce_fan_mode_input }}"
          - condition: template
            value_template: "{{ state_attr(thermostat_entity, 'fan_mode') not in [desired_fan_mode] }}"
        sequence:
          - delay: "00:01:00"   # avoid API spam if previous services run back-to-back
          - service: climate.set_fan_mode
            target:
              entity_id: !input thermostat
            data:
              fan_mode: "{{ desired_fan_mode }}"

  # Debug message is now the last action in the automation
  - choose:
      - conditions: "{{ debug_notifications_enabled }}"
        sequence:
          - service: persistent_notification.create
            data:
              title: "Smart Thermostat DEBUG {{ 'ON' if is_weather_available else 'OFF' }}"
              message: |-
                **Time:** {{ current_hour | round(1) }} h
                **Desired / Current / Δ:** {{ desired_temp }} °C / {{ current_target_temp }} °C / {{ temp_difference }} °C
                **Mode:** {{ thermostat_mode }} → **Needed:** {{ needed_mode }}
                **Range:** {{ current_target_low }} – {{ current_target_high }} °C

                {% if is_weather_available %}
                **Weather**
                • Outdoor: {{ current_outdoor_temp | round(1) }} °C ({{ current_condition }})
                • Solar impact: {{ solar_impact }}
                • Thermal mass: {% if building_thermal_contribution == 'warming' %}Heating Up{% elif building_thermal_contribution == 'cooling' %}Cooling Down{% else %}Stable{% endif %}
                • Trend: {% if natural_trend == 'warming' %}Getting Warmer{% elif natural_trend == 'cooling' %}Getting Cooler{% else %}Stable{% endif %}
                • Feels like: {{ feels_like_temp|round(1) }} °C
                {% if current_humidity != "unknown" %}• Humidity: {{ current_humidity|round(1) }} %{% endif %}
                • Indoor-Outdoor Δ: {{ (desired_temp - current_outdoor_temp) | round(1) }} °C
                {% else %}
                **Weather Integration:** Off
                {% endif %}

                {% set low_change = new_target_low|float - current_target_low|float %}
                {% set high_change = new_target_high|float - current_target_high|float %}
                {% if low_change != 0 or high_change != 0 %}
                **Action:** Adjusting setpoints → {{ new_target_low }} – {{ new_target_high }} °C
                {% if low_change != 0 %}• Heat: {{ current_target_low }} → {{ new_target_low }} ({{ low_change|round(1) }} °C){% endif %}
                {% if high_change != 0 %}• Cool: {{ current_target_high }} → {{ new_target_high }} ({{ high_change|round(1) }} °C){% endif %}
                {% else %}
                **Action:** No temperature adjustment needed
                {% endif %}

variables:
  # --- VARIABLE DEFINITIONS ---
  # This section defines all the variables used throughout the automation for clarity and reusability.
  # Aliases for blueprint inputs to make templates cleaner.
  day_target_sensor_entity: !input day_target_sensor
  night_target_sensor_entity: !input night_target_sensor
  thermostat_entity: !input thermostat
  day_temp_input_entity: !input day_temp_input
  night_temp_input_entity: !input night_temp_input
  use_day_temp_input: !input use_day_temp_input
  use_night_temp_input: !input use_night_temp_input
  day_temp_static: !input day_temp_static
  night_temp_static: !input night_temp_static
  day_start_hour: !input day_sensor_start_hour
  night_start_hour: !input night_sensor_start_hour
  sensor_timeout_hours: !input sensor_timeout
  min_temp_limit_value: !input min_temp_limit
  max_temp_limit_value: !input max_temp_limit
  weather_entity: !input weather_entity
  outdoor_temp_sensor_input: !input outdoor_temp_sensor
  use_outdoor_temp_sensor_input: !input use_outdoor_temp_sensor
  outdoor_temp_entity: >
    {% if use_outdoor_temp_sensor_input and outdoor_temp_sensor_input != "" %}
      {{ outdoor_temp_sensor_input }}
    {% else %}
      ""
    {% endif %}

  humidity_sensor_input: !input humidity_sensor
  use_humidity_sensor_input: !input use_humidity_sensor
  enforce_fan_mode_input: !input enforce_fan_mode
  fan_mode_setting_input: !input fan_mode_setting
  desired_fan_mode: "{{ fan_mode_setting_input if fan_mode_setting_input | length > 0 else 'low' }}"
  use_weather_forecast_input: !input use_weather_forecast
  debug_notifications_enabled: !input debug_notifications
  forecast_adjustment_value: !input forecast_adjustment
  solar_adjustment_value: !input solar_adjustment
  gradient_threshold_value: !input gradient_threshold
  circadian_hour_value: !input circadian_hour

  # Safety setpoint limits from blueprint inputs.
  safety_min: !input safety_min_setpoint
  safety_max: !input safety_max_setpoint

  # Determines if the weather feature should be used.
  # Checks if the toggle is enabled, an entity is provided, and the entity is not in an error state.
  is_weather_available: "{{ use_weather_forecast_input and weather_entity != none and weather_entity|length > 0 and states(weather_entity) not in ['unavailable', 'unknown', 'none'] }}"

  # Dynamically selects the active temperature sensor (day or night) based on the current time
  # and the configured start hours for day and night periods.
  current_target_sensor_entity: >
    {% set hour = now().hour %}
    {% set day_start = day_start_hour | int %}
    {% set night_start = night_start_hour | int %}
    {% if day_start < night_start %}
      {# Normal case: day_start=6, night_start=22 -> day sensor 6-21, night sensor 22-5 #}
      {% if hour >= day_start and hour < night_start %}
        {{ day_target_sensor_entity }}
      {% else %}
        {{ night_target_sensor_entity }}
      {% endif %}
    {% else %}
      {# Edge case: night_start < day_start (e.g., day_start=22, night_start=6) #}
      {% if hour >= night_start and hour < day_start %}
        {{ night_target_sensor_entity }}
      {% else %}
        {{ day_target_sensor_entity }}
      {% endif %}
    {% endif %}

  # Fetches the target temperatures from either helpers or fixed values based on the toggle.
  day_temp: >
    {% if use_day_temp_input and day_temp_input_entity != "" %}
      {{ states(day_temp_input_entity) | float(24) }}
    {% else %}
      {{ day_temp_static | float(24) }}
    {% endif %}

  night_temp: >
    {% if use_night_temp_input and night_temp_input_entity != "" %}
      {{ states(night_temp_input_entity) | float(20) }}
    {% else %}
      {{ night_temp_static | float(20) }}
    {% endif %}

  # Gets the current hour as a float (e.g., 18.5 for 6:30 PM) for use in calculations.
  current_hour: "{{ now().hour + (now().minute / 60.0) }}"

  # Calculates the "desired" temperature at any given moment using a cosine curve.
  # This simulates a natural circadian rhythm with the coolest temperature at the selected AM hour
  # and warmest at the same PM hour (12 hours later).
  desired_temp: >
    {% set dtemp = day_temp %}
    {% set ntemp = night_temp %}
    {% set hour = now().hour + (now().minute / 60.0) %}
    {% set temp_range = dtemp - ntemp %}
    {% set coolest_hour = circadian_hour_value | int %}
    {% if coolest_hour == 0 %}
      {% set coolest_hour = 0 %}
    {% endif %}

    {# Create smooth curve: coolest at the selected AM hour, warmest 12 hours later #}
    {% set phase = (hour - coolest_hour) * 15 %}  {# Convert to degrees (24h = 360°) #}
    {% set curve = (1 - cos(phase | float * 3.14159 / 180)) / 2 %} {# Inverted curve #}
    {% set dynamic_temp = ntemp + (temp_range * curve) %}

    {{ dynamic_temp | round(1) }}

  # Core temperature and thermostat state variables.
  current_target_temp: "{{ states(current_target_sensor_entity) | float(22) }}"
  thermostat_mode: "{{ states(thermostat_entity) }}"
  hvac_action: "{{ state_attr(thermostat_entity, 'hvac_action') }}"
  # The difference between the room's current temperature and the calculated desired temperature.
  temp_difference: "{{ (current_target_temp - desired_temp) | round(1) }}"
  # Current temperature setpoints from the thermostat.
  current_target_low: "{{ state_attr(thermostat_entity, 'target_temp_low') | float(22) }}"
  current_target_high: "{{ state_attr(thermostat_entity, 'target_temp_high') | float(23) }}"
  current_target_single: "{{ state_attr(thermostat_entity, 'temperature') | float(22) }}"
  # Determines the required HVAC mode (heat, cool, or heat_cool) based on the temperature difference.
  # It will suggest switching modes if the temperature is significantly off target (e.g., > 0.7°C)
  # to prevent rapid cycling between heating and cooling.
  needed_mode: >
    {% set diff = temp_difference %}
    {% if thermostat_mode == 'heat_cool' %}
      heat_cool
    {% elif thermostat_mode == 'heat' and diff > 0.7 %}
      cool
    {% elif thermostat_mode == 'cool' and diff < -0.7 %}
      heat
    {% else %}
      {{ thermostat_mode }}
    {% endif %}
  # Calculates an adaptive temperature offset. Nudges are ±0.5 °C at most and only
  # occur when the room drifts outside the permitted band:
  #   max( low set-point , desired-0.5 )  ≤  room temp  ≤  min( high set-point , desired+0.5 )
  offset_adjustment: >
    {%- set band_low  = [ current_target_low , (desired_temp - 0.5) ] | max -%}
    {%- set band_high = [ current_target_high, (desired_temp + 0.5) ] | min -%}

    {%- if current_target_temp > band_high -%}
      -0.5
    {%- elif current_target_temp < band_low -%}
      0.5
    {%- else -%}
      0
    {%- endif -%}

  # Variable for consolidated sensor validation logic
  sensors_valid: >
    {% set day_s = day_target_sensor_entity %}
    {% set night_s = night_target_sensor_entity %}
    {% set day_state = states[day_s] %}
    {% set night_state = states[night_s] %}
    {% set thermo_state = states[thermostat_entity] %}
    {% set timeout_seconds = sensor_timeout_hours * 3600 %}

    {% if day_state is none or day_state.state in ['unknown', 'unavailable', 'none'] or
          night_state is none or night_state.state in ['unknown', 'unavailable', 'none'] or
          thermo_state is none or thermo_state.state in ['unknown', 'unavailable', 'none'] %}
      false
    {% else %}
      {% set day_temp = day_state.state | float(-99) %}
      {% set night_temp = night_state.state | float(-99) %}

      {% set temp_valid = day_temp >= min_temp_limit_value and
                          night_temp >= min_temp_limit_value and
                          day_temp <= max_temp_limit_value and
                          night_temp <= max_temp_limit_value %}

      {% set sensors_fresh = (now() - day_state.last_updated).total_seconds() < timeout_seconds and
                             (now() - night_state.last_updated).total_seconds() < timeout_seconds %}
      {% set thermo_fresh = (now() - thermo_state.last_updated).total_seconds() < timeout_seconds %}
      {{ temp_valid and sensors_fresh and thermo_fresh }}
    {% endif %}

  humidity_entity: >
    {% if use_humidity_sensor_input and humidity_sensor_input != "" %}
      {{ humidity_sensor_input }}
    {% else %}
      ""
    {% endif %}
